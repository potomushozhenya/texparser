


{\small

\noindent $\issueyear$
\emph{ВЕСТНИК\,САНКТ-ПЕТЕРБУРГСКОГО\,УНИВЕРСИТЕТА Сер.\,10}
Вып.\,$\issuenum$\linebreak

}

%\ \\ \vskip 0.8mm\hrule \\ \hrule \\ \ \\

\vskip -2.5mm

\hline\vskip .5mm

\hline

\vspace{1.15cm} \noindent {\uppercase Информатика} \vspace{1.15cm}

\noindent{\footnotesize УДК 519.68}

\vskip2mm

\noindent{\it Д. В.~Калинин$^1$, М. Ю. Орехов$^{1,2}$}

\vskip1.8mm

\noindent{\bf СПЕЦИАЛИЗИРОВАННАЯ КОНТЕЙНЕРНАЯ БИБЛИОТЕКА \\ ДЛЯ
ЗАДАЧ ДИНАМИЧЕСКОГО ОТОБРАЖЕНИЯ\\ ВЕКТОРНОЙ ГРАФИКИ}

\efootnote{

\vspace{-3mm}\parindent=7mm


%{\copyright} Н. А. Валиотти, 2014

{\it Калинин Дмитрий Владимирович}~--- начальник группы
лаборатории систем автоматизации разработки моделирующих
комплексов и~тренажеров; kdv2112@mail.ru

{\it Орехов Михаил Юрьевич}~--- инженер лаборатории систем
автоматизации разработки моделирующих комплексов и~тренажеров,
аспирант; genazvale2005@yandex.ru



\vskip 2.5mm

\textit{Kalinin Dmitriy Vladimirovich}~--- training and
engineering simulators computer-aided design laboratory head of
group; kdv2112@mail.ru

\textit{Orekhov Mikhail Yurievich}~--- training and engineering
simulators computer-aided design laboratory programmer,
post-graduate student; genazvale2005@yandex.ru

{\copyright} Санкт-Петербургский государственный университет, 2016


%$^{*}$ Работа выполнена при финансовой поддержке
%Санкт-Петербургского государственного университета (грант
%№~9.38.673.2013).


}

\vskip1.8mm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
\fancyfoot[LO]{{\footnotesize\emph{DOI: 10.21638/11701/spbu10.2016.205 } }\hfill\thepage}%
\fancyfoot[RE]{\thepage\hfill{\footnotesize\emph{DOI: 10.21638/11701/spbu10.2016.205 } } }%
%\fancyfoot[LO]{\hfill{\fontsize{10.5}{10.5}\selectfont \thepage}}%
%\fancyfoot[RE]{{\fontsize{10.5}{10.5}\selectfont \thepage}\hfill}%
%\lhead{} %верхний колонтитул слева
%%\rhead{} % верхний колонтитул справа
% для оформления нижнего колонтитула
\cfoot{} %
%\lfoot{} %
%\rfoot{\thepage} %



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\footnotesize



\noindent $^1$ ФГУП <<Научно-исследовательский технологический
институт имени А. П. Александрова>>,

\noindent\hskip2.45mm Российская Федерация, 188540, Ленинградская
обл., г. Сосновый Бор, Копорское шоссе, 72




\noindent $^2$ Санкт-Петербургский государственный университет,
Российская Федерация,

\noindent\hskip2.45mm 199034, Санкт-Петербург, Университетская
наб., 7--9




\vskip1.8mm

\begin{list}{}{\leftmargin=7mm \rightmargin=7mm \listparindent=5mm}

\item \hskip5mm  Рассматриваются вопросы инструментальной поддержки разработки
системы динамической визуализации векторных
объектно-ориентированных 2D схем открытого текстового формата
в~составе комплекса моделирования сложных технических объектов
на~уровне проектирования надежной и~быстродействующей контейнерной
библиотеки. Обеспечение высокой скорости выполнения словарной
операции поиска позволяет представлять графические объекты в~виде
гибких структур~--- ассоциативных массивов атрибутов переменного
типа со~строковым индексом, упрощая создание и~сопровождение
системы отображения в~условиях неопределенности перечня типов
моделируемых объектов и~правил их динамического поведения. Быстрый
поиск атрибута по~имени приобретает особую важность для
функционирования системы в~реальном времени при визуализации схем
сложных объек\-тов с~численностью графических объек\-тов
в~несколько десятков тысяч. Помимо этого ключевого свойства
контейнерная библиотека должна удовлетворять ряду перечисленных
в~статье специфических требований. Предложен вариант реализации,
учитывающий названные ограничения. Продемонстрированы оценки
быстродействия операций вставки и~поиска для разработанного
контейнерного класса и~его аналогов из~популярных библиотек STL
и~Qt. Библиогр. 12~назв. Ил.~4.

{\it Ключевые слова}: контейнерный класс, гибкая структура, поиск
по строковому ключу, ассоциативный массив, векторная графика.

\end{list}

}

\vskip2.0mm

\noindent{\it  D. V. Kalinin$^1$,  M. Yu. Orekhov$^{1,2}$}

\vskip2mm\noindent{\bf SPECIALIZED CONTAINER LIBRARY FOR PURPOSES
\\ OF VECTOR GRAPHICS DYNAMIC DISPLAYING}

\vskip1.5mm



{\footnotesize



\noindent $^1$ Alexandrov Research Institute of Technology, 72,
Koporskoe highway, Sosnovy Bor,

\noindent\hskip2.45mm Leningrad region, 188540, Russian Federation


\noindent $^2$ St. Petersburg State University, 7--9,
Universitetskaya nab.,

\noindent\hskip2.45mm  St. Petersburg, 199034, Russian Federation


\vskip2mm


\begin{list}{}{\leftmargin=7mm \rightmargin=7mm \listparindent=5mm}

\item \hskip5mm This paper considers instrumental support issues of complex
technological objects modelling on the level of container library
design for the purposes of vector object-oriented 2D open-text
formatted schemes real-time dynamic displaying. Guaranteed rapid
key-string search allows presenting the graphical objects as
variable structures~--- string-indexed associative containers of
mutable-typed attributes, simplifying visualization system
development and maintenance under simulated objects types and
dynamic behavior patterns indeterminacy condition. Displaying
system efficiency becomes critically dependent from attribute
key-string look-up duration as modelled object complexity
increases and reveals in great amount of scheme graphical objects,
reaching several thousands. Besides this feature, container
library must answer some other specific requirements. This article
enumerates them and suggests applicable implementation. The
present paper also adduces the results of test, estimating
insertion and look-up speed, performed for designed container
class and its analogues provided by STL and Qt. Refs~12. Figs~4.

\textit{Keywords}: container class, variable structure, key-string
search, associative array, vector graphics.

\end{list}

}

\vskip 2mm



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\bf Введение.} Статья посвящена вопросам проектирования надежной
и быстродействующей специализированной контейнерной библиотеки.
Устройство контейнерного класса представлено как сочетание
двусвязного списка, непосредственно \textit{содержащего}
размещенные объекты, и~набора индексных таблиц поиска объекта
по~заданному ключу с~поддержкой сортировки и~фильтрации.

Из накопленного запаса идей, терминов и~подходов в~области
программной реализации словарей~--- конечных динамических множеств
с~определенными операциями вставки, поиска и~удаления
элементов~--- для индексной таблицы выделены альтернативные
структуры данных: хeш-таблица [1, c. 285; 2, с. 323], вариант
сбалансированного дерева поиска [1, с. 341], список с~пропусками
[3] и~сплошной массив упорядоченных идентификаторов с~функцией
бинарного поиска [2, с. 180].

В настоящей работе обоснован выбор массива ключей в~качестве
индексной таблицы: перечислены решения, позволившие уменьшить
время выполнения словарной операции поиска в~сравнении
с~древовидными структурами и~обеспечить функциональность
сортировки и~фильтрации ключей, недоступную для хeш-таблиц.

Примером области приложения контейнерной библиотеки как
инструмента разработки является среда динамической визуализации
векторных объект\-но-ориен\-ти\-ро\-ван\-ных 2D схем открытого
текстового формата~--- компоненты
про\-грамм\-но-вы\-чис\-ли\-тель\-но\-го комплекса. Одним из
условий проектирования среды был учет \textit{неопределенности}
палитры типов графических примитивов, объектов и~перечня их
атрибутов, обусловленной тем, что состав моделируемого
оборудования, а~также набор специфических свойств каждой единицы
могут быть расширены на~дальнейших этапах разработки
и~эксплуатации комплекса. Число размещенных на~схеме графических
объектов может достигать нескольких тысяч, суммарное количество их
графических атрибутов~--- десятков тысяч. Среда визуализации
должна обеспечивать редактирование и~динамическое отображение
объектов схемы в~реальном времени (с частотой обновления
не~менее\linebreak 5 FPS). Описание контекста применения среды
визуализации приводится в~работе [4] и~видеоролике [5]. Конкретная
задача, обусловившая создание среды в~этом контексте,
сформулирована в~статьях [6, 7].

В п. 1 данной статьи предложен способ организации
\textit{разнородных} атрибутов графического объекта в~виде
контейнерного класса. Характерные для области приложения
требования к~выбору структур данных его реализации перечислены
в~п. 2. Модель контейнера, удовлетворяющая названным требованиям
с~гарантией высокого быстродействия, описана в~п. 3. В~п. 4
представлены сравнительные результаты\linebreak%\newpage\noindent
тестов оценки времени выполнения операций вставки и~поиска для
разработанного контейнерного класса и~его аналогов из~библиотек
STL и~Qt.

{\bf 1. Графический объект~--- контейнер атрибутов.} В~рамках
использования открытого текстового формата схемы графические
примитивы и~объекты задаются SVG-подобными определениями
собственных атрибутов:%
\hspace*{-10mm}\begin{verbatim}
CLASS=obj  TYPE=Std_ana_veu NAME= DESCR=МощнПотребл X=2102 Y=209 Z=822 ...
CLASS=prim TYPE=ellipse NAME= DESCR=Обмотка!32трансформатора X=2610.42 ...
\end{verbatim}

Рассмотрим подход к~построению иерархии графических сущностей
с~неопределенным набором свойств (примитив, составной объект,
схема) в виде объектов \textit{гибкой} структуры~--- ассоциативных
контейнеров: таблиц идентификаторов атрибутов произвольного типа
со строковым индексом-ключом поиска, формируемых в~процессе
разбора текстового определения. Под гибкостью структуры здесь
подразумевается возможность изменения как количества элементов,
так и~их качества~--- тип хранимого значения атрибута (строковый,
целочисленный или вещественный) определяется последней операцией
присваивания. Класс <<таблица идентификаторов>> имеет вид
\begin{verbatim}
template<class Attr> class IdentifierTable {
public:   //Подстрока SubString — универсальный аргумент функций строковой
          Attr &operator()(const SubSting &AttrName);  // библиотеки [8, 9].
    const Attr &operator()(const SubSting &AttrName) const;
    ...
    virtual SString generateDefinition() const;   // Сохранение определения.
    virtual void    loadDefinition(const SubString &textFlow);  // Загрузка.
};
\end{verbatim}

\noindent Оператор <<()>> гибкой структуры, соответствующий
оператору <<.>> вычисления смещения поля в~жесткой, реализует
доступ к~полю по~строковому индексу. Он вызывает методы таблицы
идентификаторов для поиска/создания атрибута по~его имени.

Класс <<примитив>> используется для представления всей палитры
примитивов (линия, прямоугольник, эллипс и~др.) базовой
графической библиотеки:
\begin{verbatim}
class Primitive : public IdentifierTable<Attribute> {
    PlatformDependentPrim *graphicsItem; // Платформенно-зависимое
    ...                                  // представление примитива.
};
\end{verbatim}

Составной графический объект (через посредство <<примитива>>)
и~схема на\-сле\-дуют функциональность \verb"IdentifierTable" для
перечисления собственных атрибутов и~генерации/загрузки текстовых
определений, а~также содержат списки образующих их объектов
и~примитивов.

Предложенный подход позволяет обеспечить:
%\setlength{\leftmargini}{1.2em}
%\begin{itemize}\begin{itemize} %[leftmargin=0pt,itemsep=0pt,topsep=0pt,parsep=0pt,itemindent=10.5mm]

$1)$  поддержку модификаций набора свойств моделируемого объекта,
а~также динамическое создание и~удаление <<пользовательских>>
полей и~смену их типа;

$2)$ независимость от~реализации и~текущей версии графической
платформы. Переход к~иной платформе разработки среды визуализации
может повлечь изменение номенклатуры наличных графических
примитивов и~их свойств. Взаимодействие \textit{абстрактного}
контейнера со~своим платформенно-зависимым представлением
\textit{жесткой} структуры ограничивается последовательным
присваиванием значений атрибутов, инкапсулированным в~процедурах
\textit{драйвера} объекта. Таким образом, замена платформы
отразится лишь в~необходимой правке имеющихся и~вероятном введении
новых драйверов согласно расширению набора примитивов;

$3)$  возможность создания окон графического интерфейса без учета
специфики объек\-тов воспроизведения. Рассмотрим пример окна
свойств графического объекта: при применении контейнерной модели
достаточно реализовать одну функцию обновления окна, считывающую
имена и~значения атрибутов в~цикле, вместо нескольких функций,
обращающихся к~полям каждой из~сущностей жесткой конфигурации;

$4)$  отвлечение механизма динамического обмена от~особенностей
графических объек\-тов. Этот механизм проецирует величину
моделируемого параметра на~значение графического свойства для
управляющих параметров и~осуществляет обратное преобразование для
управляемых. Использование абстрактного интерфейса именованного
доступа к~атрибутам позволяет обобщить процедуру преобразования.
%\end{itemize}\end{itemize}

{\bf 2. Требования к~проектированию.} Основным и~критическим
требованием к~предлагаемой реализации, гарантирующим высокое
быстродействие, являются малые временные издержки \textit{поиска}
по строковому ключу. Это условие становится очевидным на~примере
динамического отображения схемы с~большим числом объектов. Пусть
для визуализации расчета некоторой моделирующей задачи из~общего
числа графических атрибутов объектов необходимо модифицировать 10
000. Тогда для воспроизведения схемы с~частотой 5 FPS следует 5
раз в~секунду выполнить составную операцию обновления, несколько
раз включающую поиск 10 000 имен в~различных контейнерах.

На скорость поиска по~строковому индексу помимо особенностей
самого контейнера оказывает влияние время работы оператора
\textit{сравнения} ключей. Предполагается использование
контейнерной библиотеки совместно со~специализированной строковой
библиотекой, где операции сравнения и~копирования строк близки
по~быстродействию к~соответствующим низкоуровневым функциям
стандартной библиотеки [8, 9].

В силу характера используемых данных контейнер должен поддерживать
\textit{дублирование} ключей, а~также группирование одноименных
элементов с~доступом по~ключу и~целочисленному индексу.
К~нескалярным графическим свойствам относятся коор\-динаты вершин
многоугольника, компоненты цвета, точки градиента и~т.~д.

Для обеспечения разнообразия форм представления графической
информации обязательно оснащение контейнерной библиотеки
средствами \textit{сортировки} и~\textit{фильтрации} данных
по~заданному, вероятно, составному критерию. С~наличием таких
инструментов пользователь среды отображения приобретает
возможность выбрать атрибуты имеющихся объектов схемы, наложить
фильтры и~установить направление сортировки по~\textit{каждому}
из~них, чтобы в~полученном перечне внести контекстные изменения,
скажем, в~маркировках моделируемого оборудования.

Учитывая предполагаемые масштабы задачи визуализации и~большое
число итераций циклов вставки и~удаления при формировании
контейнеров графических объек\-тов, необходимо требовать
\textit{минимизации} создания временных и~служебных объек\-тов,
заключающих хранимые данные, поскольку обилие запросов выделения
блоков памяти разных размеров способствует фрагментации кучи.

{\bf 3. Описание реализации.} В~качестве схематической модели
самого общего устройства контейнерного класса рассматривается
двусвязный список, дополненный набором индексных таблиц.
Список-владелец содержит данные \textit{непосредственно}, имеет
по\-стоян\-ное время вставки в~начало и~в~конец. Каждая из~таблиц
обеспечивает\linebreak минимальное время поиска элемента
по~заданному ключу, а также упорядочение и~вывод данных
по~некоторому правилу. В~п. 3.1--3.7 представлен вариант
реализации содержания предложенной формы, передающего ей
необходимые свойства для соответствия перечисленным ранее
условиям. На~рис.~1 приведена иерархия опи\-сы\-вае\-мых
программных классов в~графической нотации UML со~спецификацией
внешних и~внутренних интерфейсов.
\begin{figure}[h!]
\centering{
\includegraphics[scale=1]{05/fig1}

\vskip 2mm {\small{\it Рис. 1.} Иерархия программных классов} }
\end{figure}


%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=14cm]{fig1} \linebreak
%
%{\small {\it Рис. 1.} Иерархия программных классов}
%\end{center}
%\end{figure}

\emph{\textbf{3.1. Абстрактный узел списка item.}} Требование
минимального употребления вспомогательных объектов при размещении
данных выполняется, если все по\-тен\-циаль\-но вносимые
в~контейнер сущности являются потомками абстрактного <<узла>>
двусвязного списка. Этим помимо унификации размеров выделяемых
блоков уменьшается число обращений к~динамической памяти ввиду
отсутствия потребности в~служебных объектах. Принципиальная
функциональность узла инкапсулируется в~классе \verb"item":
\begin{verbatim}
class item {
    mutable item *_next,*_prev;
protected:
    static void link(const item *i)               // Замкнуть на себя.
        { i->_prev=i->_next=(item*)i; }
    static void link(const item *p,const item *n) // Связать аргументы.
        { (p->_next=(item*)n)->_prev=(item*)p; }
    static void unlink(const item *i)             // Извлечь из списка.
        { (i->_prev->_next=i->_next)->_prev=i->_prev; }
    static void ins(const item *m,const item *i)  // Вставить i перед m.
        { link(m->_prev,i);link(i,m); }
    static int nol(const item *i) { ... } // Элемент не связан (замкнут).
public:
    item() { }
    item(const item &) { link(this); }    // Замкнуть созданную копию.
    void operator=(const item &) { }
    virtual ~item() { }
    ...
};
\end{verbatim}

\emph{\textbf{3.2. База наследования элементов контейнера elem.}}
Производство элементов от~общего предка допускает совместное
хранение объектов разных уровней иерархии. Наследование с~ключом
\verb"private" делает «происхождение» от~\verb"item" скрытым как
для потомков \verb"elem", так и~для внешних классов за~исключением
дружественных:
\begin{verbatim}
class elem : private item {
    friend class lst; friend class cntr;
public:
    elem()            : item(*this) { } // Новый элемент замкнут.
    elem(const elem&) : item(*this) { } //
    ~elem() { if(!item::nol()) err("linked somewhere"); } // Аварийный выход
    ...                        // при попытке деструкции связанного элемента.
};
\end{verbatim}

\emph{\textbf{3.3. Список временного хранения lst.}} Описываемая
реализация линейного двусвязного списка предполагает
\textit{владение} элементами для предотвращения их многократного
уничтожения: два контейнера не~могут иметь общих элементов,
деструкция контейнера предусматривает деструкцию данных. Поэтому
передача части элементов между списками-владельцами возможна либо
созданием <<глубокой>> копии, либо путем вырезки. Вырезки
\textit{перемещаемых} (move) элементов организуются в~виде
кольцевых списков промежуточного хранения~--- объектов класса
\verb"lst":
\begin{verbatim}
class lst : private item { // Головной элемент списка.
    friend class cntr;
    mutable uint len;      // Число элементов.
    ...
    static void ins(const item *m,const elem *e); // Вставить e перед m.
    static uint ins(const item *m,const lst &l);  // Вставить содержимое l
protected:                                        // перед m. Замкнуть l.
    struct _cut_p { };                      // Абстрактная граница вырезки.
    typedef void _cut_f   (lst *out,_cut_p *from); // Методы вырезки в out.
    typedef void _cut_to_f(lst *out,_cut_p *from,const _cut_p *to); //
    ...
    lst &operator=(const lst &l);        // Переместить (move) содержимое l.
    lst &operator<<(elem *e) { ins(this,e);++len;return *this; } // Вставка
    lst &operator<<(const lst &l);                        // в конец списка.
public:
    lst() : item(*this) { len=0; }
    lst(const lst &l); // Переместить содержимое l.
    // «Виртуальные» конструкторы lst.
    lst(_cut_f *fn,_cut_p *from)                     { fn(this,from); }
    lst(_cut_to_f *fn,_cut_p *from,const _cut_p *to) { fn(this,from,to); }
    ~lst(); // Деструкция содержимого.
    ...
};
\end{verbatim}

Возможность вырезки элементов из~заданного источника
обеспечивается применением механизма <<виртуального>>
(фактического) конструирования, избавляющего от~необходимости
включения в~состав \verb"lst" специфических конструкторов для
каждого вероятного потребителя: конкретный способ вырезки
сообщается экземпляру \verb"lst" в~момент создания параметрически.
Механизм использует \textit{стандартное} свойство языка [10]
опускать промежуточные конструкторы, поддерживаемое оптимизирующим
компилятором. Вызов <<виртуальных>> конструкторов разрешен
объектам классов, имеющих доступ к~определению абстрактных границы
и методик вырезки.

Контроль типов хранимых элементов осуществляется введением шаблона
\verb"Lst" с~опубликованными операторами присваивания и~вставки.
Так, конкретная инстанция \verb"Lst" может содержать потомков
\verb"elem" одного уровня и~ниже, попытка же размещения
в~\verb"Lst" более абстрактного представителя иерархии будет
блокирована компилятором:
\begin{verbatim}
template <class Elem> class Lst : public lst {
public:
    Lst &operator=(const Lst &l) { return (Lst&)lst::operator=(l); }
    Lst &operator<<(Elem *e)     { return (Lst&)lst::operator<<(e); }
    ...
};
\end{verbatim}

\emph{\textbf{3.4. База наследования структур данных контейнера
cntr.}} Каждый список-владелец элементов контейнера ассоциируется
с~одной или несколькими индексными таблицами. Для упрощения
взаимодействия этих сущностей и~управления ими предлагается
использовать единую базу наследования~--- \verb"node", что
позволяет организовывать индексные таблицы в~кольцевой список
вокруг головного элемента~--- списка контейнера~---
с~автоматической регистрацией при создании и~извлечением при
деструкции:
\begin{verbatim}
class node : public item { // Потомкам «известно» о происхождении от item.
public:
    node()              : item(*this) { } // Головной элемент списка.
    node(const node &n) : item() { ins(&n,this); } // Вставка перед n.
    ~node( ) { unlink(this); }            // Деструкция с извлечением.
    node &operator=(const node &n)        // Смена списка.
        { unlink(this);ins(&n,this);return *this; }
    ...
};
\end{verbatim}

Класс \verb"cntr", как \textit{общий} предок линейного двусвязного
списка-владельца элементов контейнера и~индексной таблицы,
поддерживает константные (RO~--- read-only) и~неконстантные
(RW~--- read-write) итераторы. RO-итератор на~время своего
существования блокирует модификации объекта \verb"cntr",
увеличивая счетчик \verb"cntr::lock". RW-итераторы, порожденные
от~\verb"node", формируют кольцевой список для автоматической
проверки и~коррекции их позиций при вставке и~вырезке элементов
экземпляра \verb"cntr". Попытка вырезки итерируемого фрагмента
списка приводит к~\textit{явному} аварийному завершению работы,
чем обеспечивается \textit{надежность} итерирования:
\begin{verbatim}
class cntr : protected node { // Элемент кольцевого списка.
    void init() { lock=0; len=0; h=t=NULL; }
protected:
    node itrs;         // Головной элемент кольцевого списка RW-итераторов.
    mutable uint lock; // Счетчик блокировок модификаций.
    uint len;          // Число хранимых элементов.
    elem *h,*t;        // Граничные элементы («до первого» и «за последним»).
    typedef lst::_cut_p _cut_p; // Поддержка «виртуального» конструирования
    typedef lst::_cut_f _cut_f; // lst для потомков и RW-итераторов.
    typedef lst::_cut_to_f _cut_to_f; //
    ...
    cntr() : node() { init(); }   // Головной элемент кольцевого списка.
    cntr(const cntr &n) : node(n) { init(); } // Элемент списка перед n.
public:
    class __itr; friend class __itr; // База наследования итераторов.
    ...
};
\end{verbatim}

Дополнительным преимуществом проектирования структур данных
контейнера на~едином основании является возможность выделения
общих свойств и~методов константных и~неконстантных итераторов
списка и~индексной таблицы в~корне иерархии наследования~---
классе \verb"cntr::__itr":
\begin{verbatim}
class cntr::__itr {
    friend class cntr;
protected:
    elem *c;         // Текущий элемент.
    cntr *r;         // Итерируемая структура данных.
    mutable uint cp; // Текущая позиция.
    ...
    __itr(const cntr &l)  { *this=l; } // К элементу h.
    __itr(const __itr &m) { *this=m; } // К элементу m.c.
    void operator=(const cntr &l)  { c=l.h;r=(cntr*)&l;cp=0; }
    void operator=(const __itr &m) { c=m.c;r=m.r;cp=m.cp; }
};
\end{verbatim}

\emph{\textbf{3.5. Список элементов контейнера list.}}
Функциональное содержание индексируемого итерируемого двусвязного
линейного списка, реализованное в~классе \verb"list", гарантирует
автоматическую реиндексацию таблиц своих элементов и~правку
позиций RW-итераторов в~методах вставки и~вырезки. Контейнер
\verb"list" определяет собственные итераторы через общую базу
\verb"list::_itr", дополняющую возможности \verb"cntr::__itr"
методами инкремента, смещения и~т.~п. Контроль типов хранимых
элементов обеспечивается на~уровне шаблона \verb"List" с~открытыми
операторами присваивания и~вставки:
\begin{verbatim}
class list : private cntr { // Головной элемент списка индексных таблиц.
    friend class idx;
    class _itr; friend class _itr; // База наследования итераторов.
                                   // : protected cntr::__itr.
    void init(uint sz); // Разместить и связать элементы h и t размером sz.
protected:
    static void _cut(lst *out,list *l); // Вырезать все элементы.
    list &operator=(const lst &l) { if(len)del();return *this<<l; }
    list &operator<<(elem *e);          // Вставка в конец списка.
    list &operator<<(const lst &l);     // Присвоить содержимое l.
public:
    class citr; friend class citr;      // Декларация RO-итератора.
    class itr;  friend class itr;       // Декларация RW-итератора.
    ...
    list(uint sz=sizeof(elem)) : cntr() { init(sz); }
    list(const lst &l,uint sz=sizeof(elem)); // Заимствовать элементы l.
    ~list();                            // Деструкция элементов.
    ...
    lst cut() { return lst((_cut_f*)_cut, (_cut_p*)this); } // Вырезать.
    list &del();                      // Вырезав, уничтожить содержимое.
};
\end{verbatim}

Неконстантный итератор \verb"list::itr" определяет операторы
вставки за текущий элемент и ряд методов <<виртуального>>
конструирования хранилищ вырезок \verb"lst":
\begin{verbatim}
class list::itr : private node, private _itr {
    friend class citr; // citr «известно» о происхождении itr от _itr.
protected:
    // Методы «виртуального» конструирования lst. Вырезать
    static void _cut (lst *out,itr *m);      // элемент, сместиться вправо.
    static void _cut_rest(lst *out,itr *m);  // элементы правее включительно.
    static void _cut_to(lst *o,itr *m,const itr *n); // элементы правее до n,
    ...                                              // включая текущий.
    itr &operator<<(elem *e);                // Вставить правее, сместиться
    itr &operator<<(const lst &l);           // к последнему вставленному.
public:
    itr(list &l)      : node(l.itrs),_itr(l) { } // Регистрация в списке
    itr(const itr &m) : node(m),     _itr(m) { } // при создании
    itr &operator=(list &l);                     // и смене контейнера.
    ~itr() { }                           // Извлечение из списка итераторов.
    lst cut() { return lst((_cut_f*)_cut,(_cut_p*)this); } // Методы вырезки.
    ...                                                    //
    lst cut_to(const itr &n)                               //
       { return lst((_cut_to_f*)_cutr_to,(_cut_p*)this,(const _cut_p*)&n); }
};
\end{verbatim}

\emph{\textbf{3.6. Индексная таблица списка контейнера idx.}}
Перечислим возможные варианты реализации индексной таблицы,
поддерживающие дублирование ключей:
%\begin{itemize} [leftmargin=0pt,itemsep=0pt,topsep=0pt,parsep=0pt,itemindent=10.5mm]

$\bullet$ хеш-таблица;

$\bullet$  популярные при проектировании ассоциативных контейнеров
структуры данных: красно-черное дерево [1] и~список с~пропусками
[3], используемые разработчиками библиотек STL
(\verb"std::multimap") и~Qt (\verb"QMultiMap") соответственно [11,
12], гарантирующие вставку и~поиск с~логарифмическими затратами
времени в~худшем случае;

$\bullet$  \textit{сплошной} упорядоченный массив с~бинарным
поиском объектов: при логарифмическом порядке роста временных
издержек поиска в~худшем случае время вставки будет меняться
линейно: сортировка потребует перемещения элементов вправо.
%\end{itemize}

Отказ от~применения хеш-таблиц мотивируется, во-первых,
принципиальной невозможностью представления ключей
в~отсортированном виде с~сохранением эффективности выполнения
словарных операций и, во-вторых, высокими издержками обращения
с~составным ключом. Рассмотрим пример поиска записи в~таблице
по~ключу, образованному строковыми значениями нескольких полей.
В~этом случае для использования хеш-функции от~строкового ключа,
поставляемой с~реали\-за\-цией хеш-таблицы, необходима
конкатенация значений данных полей с~неизбежным об\-ращением
к~динамической памяти для создания и~уничтожения буфера
результи\-рую\-щей строки. Альтернативой объединению строк
является дооснащение реализа\-ции собственными
\textit{качественными} хеш-функциями генерации индекса для
\textit{каждой} комбинации полей ключа поиска.

Основанием выбора сплошного массива служит его превосходство
по~результатам теста быстродействия операции поиска, приведенным
в~п. 4. Здесь же назовем ряд факторов, обеспечивающих этот
результат:
%\begin{itemize} [leftmargin=0pt,itemsep=0pt,topsep=0pt,parsep=0pt,itemindent=10.5mm]

$\bullet$   возможность хранения \textit{индекса} последнего
найденного элемента в~качестве начальной позиции повторного
поиска;

$\bullet$   \textit{меньшее} по~отношению к~древовидным структурам
число операций сравнения в~худшем случае, равное
$\lfloor\log_{2}(n)\rfloor+1$ [2];

$\bullet$   \textit{локализованное} размещение как самого массива,
так и~объектов списка, находящихся близко друг к~другу в~виду
малой фрагментированности кучи, позволяющее более эффективно
использовать кэш процессора. В~то же время издержки операции
разыменования указателей на~служебные объекты (<<узлы>>)
древовидной структуры, расположенные на~страницах памяти
\textit{разреженно}, при интенсивном поиске ока\-зы\-вают\-ся
весьма высокими.
%\end{itemize}

Отметим принципиальные особенности разработанной индексной
таблицы. Класс \verb"idx" включает массив указателей на~элементы
контейнера. Крайние элементы массива хранят указатели на~граничные
элементы списка. Состав и~очередность указателей в~массиве
определяются согласно заданным условиям фильтрации и~сортировки.
Наборы элементов с~равными ключами образуют в~массиве группы
дубликатов.

Положение элемента контейнера в~индексной таблице вычисляет
функция бинарного поиска с~непосредственной передачей ключа
поиска. Функция возвращает позицию первого найденного элемента
списка с~заданным ключом, кэшируя ее в~поле \verb"idx::found",
либо 0, если поиск оказался неуспешным. В~случае же неудачного
поиска в~\verb"found" записывается индекс элемента с~ближайшим
\textit{снизу} ключом. В~дальнейшем значение \verb"found"
используется как начальная позиция бинарного поиска.

Таблицы \verb"idx", имея предком класс \verb"node", при создании
связываются в~кольцевую структуру для обновления в~обработчиках
модификации списка элементов контейнера. Наследование \verb"idx"
от \verb"cntr" обеспечивает поддержку константных и~неконстантных
итераторов произведением их от~общей базы \verb"cntr::__itr",\
делает возможным применение механизма блокировки на~время
реиндексации и~константного итерирования, предоставляет доступ
к~<<виртуальным>> конструкторам промежуточных хранилищ \verb"lst".
Процедура вырезки из~таблицы подразумевает формирование связанной
после\-довательности извлекаемых элементов основного списка
в~заданном таблицей \textit{по\-рядке}:\newpage
\begin{verbatim}
class idx : private cntr {
    friend class list;
protected:
    idx(list &l);
    struct key { }; // Абстрактный ключ поиска.
    ...             // Доступ к «виртуальным» конструкторам lst.
private:
    list *r;    // Основной список контейнера.
    elem **tbl; // Упорядоченный массив указателей на элементы контейнера.
    mutable uint found; // Кэшируемый индекс найденного элемента.
    class _itr; friend class _itr; // База наследования итераторов
                                   // : protected cntr::__itr.
    // Методы сортировки и фильтрации.
    virtual int _cmp(const key &k,const elem *e) const = 0;
    virtual int _filter(const elem *e)           const = 0;
    uint seek(const key& k) const; // Функция бинарного поиска.
    // Обновить таблицу при модификации основного списка:
    void insx(elem *p,elem *n); // вставить
    void cutx(elem *p,elem *n); // удалить последовательность (p,n).
           // Методы вырезки. //
    static void __cut(lst *out,idx *x,uint start,uint end);
    ...
protected: //
    static void _cut (lst *out,idx *x) { __cut(out,x,1,x->len); }
    ...
public:    //
    lst cut() { return lst((_cut_f*)_cut, (_cut_p*)this); }
    ...
    class citr; friend class citr; // RO-итератор : private _itr.
    class itr;  friend class itr;  // RW-итератор : private node,
                                   //               private _itr.
};
idx::idx(list &l) : cntr(l), r(&l), found(0) {
    h=(elem*)l.head(); t=(elem*)l.tail();
    tbl=new elem**[2]; tbl[0]=h; tbl[1]=t;
}
\end{verbatim}

\emph{\textbf{3.7. Средства сортировки и~фильтрации.}} В~теле
функции бинарного поиска вызывается метод сравнения аргумента
с~содержащимся в~элементе контейнера ключом. Поскольку способ
извлечения ключа из~элемента на~этом уровне абстракции не~задан,
метод сравнения \verb"idx::_cmp" является чисто виртуальным:
\begin{verbatim}
uint idx::seek(const key &k) const {
    register uint i; register int c;
    if((i=found)!=0u) {     // Начать поиск с кэшируемого значения.
        if((c=_cmp(k,tbl[i]))==0) return i;  // Совпадение найдено.
        if(c<0) ... // Назначить границы и перейти
    } ...           // к циклу бинарного поиска.
}
\end{verbatim}

Проверка адекватности условию фильтрации выполняется при обработке
добавления элементов в~основной список чисто виртуальным методом
\verb"idx::_filter":
\begin{verbatim}
void idx::insx(elem *p,elem *n) {  // В список вставлена вырезка (p;n).
    elem *i=p;
    for( ; (i=list::next(i))!=n; ) {
        if (!_filter(i)) continue; // Анализ выполнения условия.
        ...                        // Поиск позиции для вставки в таблицу.
    }
}
\end{verbatim}

Конкретное содержание абстрактные члены получают в~составе шаблона
\verb"Idx", которому при создании кроме типа элемента контейнера
сообщаются тип ключа поиска, а~также типы функциональных классов,
устанавливающих методику сравнения двух ключей, правило извлечения
ключа из~элемента контейнера и~критерий фильтрации:
\begin{verbatim}
template <class Elem,class Key,class Cmp,class Extr,class Filter>
class Idx : public idx {
    virtual int _cmp(const key &k,const elem *e) const
        { return _cmp_( (const Key&)k,_extr_(*((Elem*)e)) ); }
    virtual int _filter(const elem *e) const
        { return _filter_( *((Elem*)e) );
public:
    Cmp    _cmp_;
    Extr   _extr_;
    Filter _filter_;
    ...
};
\end{verbatim}

Для описания функциональных классов можно воспользоваться
макросами:
\begin{verbatim}
#define defComparer(id, expr) struct id { template <class Key1,class Key2> \
    int operator() (const Key1 &k1,const Key2 &k2) const { return expr; } }
#define defExtractor(id, type, expr) struct id { template <class Elem> \
    type operator() (const Elem &e) const { return expr; } }
#define defFilter(id, expr) struct id { template <class Elem> \
    int operator() (const Elem &e) const { return expr; } }
\end{verbatim}

Проиллюстрируем работу средств сортировки и~фильтрации:
\begin{verbatim}
struct Attribute : public elem { // Сущность для хранения.
    Attribute(const SString &name,int val): _name(name), _value(val) { }
    SString _name;
    int    _value;           // Значение — целое, методы смены типа опущены.
};
defExtractor(AttrKey,const SubString&,subString(e._name); // Строковый ключ.
defComparer(AttrCmp,compare(k1, k2));   // Сравнить ключи лексикографически.
defFilter(AttrFilter,e._value > 5);     // Значение > 5.
typedef Idx<Attribute, SubString, AttrCmp, AttrKey, AttrFilter> AttrTab;

int main(int argc, char** argv) {
    List<Attribute> attributes;  // Контейнер атрибутов.
    AttrTab attrTab(attributes); // Индексная таблица.
    for (int i = 10; i > 0; --i) // Сформировать список.
        attributes << new Attribute(“Attr#” / i2a(i), i); // Attr#i
    for (AttrTab::citr i(attrTab); !(++i)->eol();) // Содержимое таблицы.
        std::cout << i->_name << “_” << i->_value << “\t”;
    // Вывод печати: Attr#10_10 Attr#6_6 Attr#7_7 Attr#8_8 Attr#9_9
    return 0;
}
\end{verbatim}

{\bf 4. Демонстрация быстродействия операций вставки и~поиска.}
Тест определения скорости вставки в~контейнерный класс
представляет собой измерение времени циклического добавления
объекта \verb"Attribute" в~связный список и~указателя на~него
в~индексную таблицу. При испытании контейнеров библиотек STL и~Qt
использовались соответствующие сочетания связных списков
\verb"std::list<Attribute>" и~\verb"QLinkedList<Attribute>"
с~индексными таблицами \verb"std::multimap<SString,Attribute*>"
и~\verb"QMultiMap<SString,Attribute*>". Тест выполнен для
компилятора gcc4.4.0. Метки на~оси абсцисс обозначают размер
массива входных данных, ординаты точек кривых фиксируют результат
в секундах. В~обоснование числовых параметров эксперимента
отметим, что указанные размеры массива данных характерны для
прикладной задачи динамической визуализации, а~именно для таблицы
моделируемых параметров расчетной задачи.



Время вставки 150 000 элементов в~список \verb"attributes"
и~таблицу \verb"attrTab" разработанного контейнерного класса
в~худшем (ключи поиска расположены по~убыванию) и~в~среднем случае
(данные частично упорядочены по~возрастанию~--- первыми сле\-дуют
элементы с~четным индексом в~ключе, затем остальные) оказывается
относительно \textit{наибольшим} (рис.~2). Если же входной поток
информации сортирован по~возрастанию, длительность вставки~---
\textit{наименьшая} (рис.~3). При анализе этих оценок необходимо
учитывать специфику вставляемых графических данных, формируемых
при разборе строк \textit{частично упорядоченных} атрибутов:
текстовые определения графических объектов могут генерироваться
с~перечислением атрибутов по~алфавиту, т.~е. по~возрастанию.
\begin{figure}[h!]
\centering{
\includegraphics[scale=1]{05/fig2}

\vskip 2mm {\small{\it Рис. 2.} Оценки быстродействия операции
вставки в~худшем и~среднем случаях} }
\end{figure}
\begin{figure}[h!]
\centering{
\includegraphics[scale=1]{05/fig3}

\vskip 2mm {\small{\it Рис. 3.} Оценки быстродействия операции
вставки в~лучшем случае} }
\end{figure}


%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=12.5cm]{fig2} \linebreak
%
%{\small {\it Рис. 2.} Оценки быстродействия операции вставки
%в~худшем и~среднем случаях}
%\end{center}
%\end{figure}
%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=12.5cm]{fig3} \linebreak
%
%{\small {\it Рис. 3.} Оценки быстродействия операции вставки
%в~лучшем случае}
%\end{center}
%\end{figure}


\textit{Комплексный} тест быстродействия поиска в~каждой из~пяти
итераций цикла производит пятикратный поиск в~контейнере данного
размера каждого элемента с~извлечением его значения. Время поиска
в \verb"attrTab" является относительно \textit{наименьшим}
безусловно (рис.~4). В~зависимости от~страничного размещения
элементов, определяемого очередностью создания, и~степени
упорядоченности последовательности разыскиваемых ключей время
работы функции бинарного поиска индексной таблицы
опи\-сы\-вает\-ся одним из~графиков, заключенным между кривыми
\verb"AttrTabBest" и~\verb"AttrTabWorst". Кривые соответствуют
максимальной и~минимальной эффективностям программного (на уровне
\verb"idx::seek") и~аппаратного (на уровне процессора)
кэширования.
\begin{figure}[h!]
\centering{
\includegraphics[scale=1]{05/fig4}

\vskip 2mm {\small{\it Рис. 4.} Оценки быстродействия операции
многократного поиска} }
\end{figure}


%\begin{figure}[!h]
%\begin{center}
%\includegraphics[width=12.5cm]{fig4} \linebreak
%
%{\small {\it Рис. 4.} Оценки быстродействия операции многократного
%поиска}
%\end{center}
%\end{figure}

Полученные результаты согласуются с теоретическими
характеристиками тестируемых структур данных. Ордината точки
каждой представленной кривой есть измерение времени работы цикла,
т.~е. сумма измерений времени выполнения рассматриваемой словарной
операции для контейнера, размерностью равной ее абсциссе.
Размерность итеративно изменяется во~внешнем цикле от~1000
элементов с~шагом 1000. Время вставки в~упорядоченный массив
в~худшем случае имеет линейный порядок\linebreak\newpage\noindent
роста~--- $O(n)$, так как требует перемещения всех элементов
вправо на~каждой итерации. Таким образом, если обозначить абсциссу
точки кривой \verb"AttrTabWorst" как $n$, ее ордината с~учетом
времени поиска ключа должна иметь зависимость
$$\displaystyle \sum_{i=1}^n (i + \lfloor\log_{2}i\rfloor+1)
\approx \sum_{i=1}^n i = n \cdot (n+1)/2,$$ т.~е. изменяться
квадратично, что и~видно на~рис.~2. Словарные операции древовидных
структур теоретически относятся к~логарифмическому классу
эффективности~--- $O(\log n)$ [1, 2]. Это означает, что ордината
точки кривой \verb"StlMultiMap" с~абсциссой $n$ должна выражаться
как $$\displaystyle \sum_{i=1}^n \log_2i = \log_2 n!,$$ т.~е.
изменяться логарифмически, что и~отражено на~рис.~2--4.

Учитывая полученные результаты, простоту организации структур
данных и~выполнение предъявленных условий, можно сделать вывод
о~целесообразности выбора упорядоченного массива для реализации
индексной таблицы. Применение созданной контейнерной библиотеки
в~качестве одного из~основных инструментов разработки графической
среды визуализации предоставляет функциональные возможности:
%\begin{itemize} [leftmargin=0pt,itemsep=0pt,topsep=0pt,parsep=0pt,itemindent=10.5mm]

$\bullet$   правки векторных графических 2D схем визуализации
результатов расчета моделирующих задач в~редакторах схем,
объектов, свойств и~групп свойств с~поддержкой операций отмены
и~повтора модификаций (undo/redo);

$\bullet$   хранения разработанных пользователем графических
объектов (схемы, графические объекты, связи) и~наборов их свойств
(цвета, кисти, перья, шрифты) в~соответствующих библиотеках
с~каскадным обновлением схем при изменениях библиотек;
%\end{itemize}
и гарантирует технические характеристики:
%\begin{itemize} [leftmargin=0pt,itemsep=0pt,topsep=0pt,parsep=0pt,itemindent=10.5mm]

$\bullet$   передачи схемам управляющих воздействий~---
обеспечения их динамического отображения на~компьютере <<офисной>>
архитектуры с~частотой до~50 FPS;

$\bullet$   времени загрузки насыщенных схем (более 1000 объектов)
–- 0.3--0.7 с.
%\end{itemize}

\textbf{Заключение.} Сформулированы требования к~проектированию
надежного и~быстродействующего специализированного контейнерного
класса, применимого в~задачах динамического отображения векторных
схем большого числа модели\-руе\-мых объектов. Обоснован выбор
структур данных, отмечены ключевые аспекты ва\-рианта реализации.
Приведены оценки быстродействия операций вставки и~поиска для
описанного контейнера в~сравнении с~его аналогами из~библиотек STL
и~Qt.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\input{05/lit-ra}



\input{05/ref-s}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\footnotesize



\vskip 3mm

%\thispagestyle{empty}


\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
\fancyfoot[LO]{\footnotesize{\it{Вестник~СПбГУ.~Сер.~10.~Прикладная~математика.~Информатика...~2016.~Вып.~2}}
\hfill}%
\fancyfoot[RE]{\hfill\footnotesize{\it{Вестник~СПбГУ.~Сер.~10.~Прикладная~математика.~Информатика...~2016.~Вып.~2}}}%
%\lhead{} %верхний колонтитул слева
%%\rhead{} % верхний колонтитул справа
% для оформления нижнего колонтитула
\cfoot{} %
%\lfoot{} %
%\rfoot{\thepage} %


\noindent Статья рекомендована к~печати проф. Л. А. Петросяном.

\vskip 1mm

\noindent Статья поступила в~редакцию 14 ноября  2015~г.

\vskip 1mm

\noindent Статья принята к печати 25 февраля  2016~г.

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\vskip 5mm

%{\footnotesize

%\noindent К\,о\,н\,т\,а\,к\,т\,н\,а\,я\,
%и\,н\,ф\,о\,р\,м\,а\,ц\,и\,я \nopagebreak \vskip 3mm

%{\it Балонин Николай Алексеевич}~-- доктор технических наук,
%профессор; e-mail: korbendfs@mail.ru

%{\it Сергеев Михаил Борисович}~-- доктор технических наук,
%профессор,  директор; e-mail: mbse@mail.ru

%\vskip 2mm

%\emph{Balonin Nikolaj Alekseevich}~-- doctor of technical
%sciences, professor; e-mail: korbendfs@mail.ru


%\emph{Sergeev Mikhail Borisovich}~-- doctor of technical sciences,
%director; e-mail: mbse@mail.ru


%}


%\thispagestyle{empty}
