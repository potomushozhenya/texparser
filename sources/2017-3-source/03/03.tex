


\zagol{004.93.51}{Т.~М.~Косовская, Д.~А.~Петров}{ВЫДЕЛЕНИЕ НАИБОЛЬШЕЙ ОБЩЕЙ ПОДФОРМУЛЫ \\
ПРЕДИКАТНЫХ ФОРМУЛ ДЛЯ РЕШЕНИЯ\\ РЯДА ЗАДАЧ ИСКУССТВЕННОГО
ИНТЕЛЛЕКТА%$^*$
}{



\vspace{-3mm}\parindent=7mm



%{\copyright} А.~В.~Буре, 2014

\textit{Косовская Татьяна Матвеевна} --- доктор
физико-математических наук, профессор;\\ kosovtm@gmail.com


\textit{Петров Дмитрий Андреевич} --- студент; imsohay@gmail.com



\vskip 2mm

\emph{Kosovskaya Tatiana Matveevna} --- doctor of physical and
mathematical sciences, professor;\\  kosovtm@gmail.com

\emph{Petrov Dmitrii Andreevich} --- student; imsohay@gmail.com

\vskip 2mm

%$^*$ Работа выполнена при финансовой поддержке
%Санкт-Петербургского государственного университета (грант №
%9.37.345.2015).


{\copyright} Санкт-Петербургский государственный университет,
\issueyear %
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
%\fancyfoot[LO]{{\footnotesize\emph{\doivyp03 } }\hfill\thepage}%
\fancyfoot[LO]{{\footnotesize\rm{\doivyp/spbu10.\issueyear.\issuenum03}}\hfill\thepage}%
%\fancyfoot[RE]{\thepage\hfill{\footnotesize\emph{\doivyp03 } } }%
\fancyfoot[RE]{\thepage\hfill{\footnotesize\rm{\doivyp/spbu10.\issueyear.\issuenum03}}}%
%\fancyfoot[LO]{\hfill{\fontsize{10.5}{10.5}\selectfont \thepage}}%
%\fancyfoot[RE]{{\fontsize{10.5}{10.5}\selectfont \thepage}\hfill}%
%\lhead{} %верхний колонтитул слева
%%\rhead{} % верхний колонтитул справа
% для оформления нижнего колонтитула
\cfoot{} %
%\lfoot{} %
%\rfoot{\thepage} %



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\footnotesize \noindentСанкт-Петербургский государственный
университет, Российская Федерация, \\ 199034, Санкт-Петербург,
Университетская наб., 7--9



\vskip2.0mm


\begin{list}{}{\leftmargin=7mm \rightmargin=7mm \listparindent=5mm}


\item В задачах искусственного ителлекта, в~которых объект представлен
как множество составляющих его элементов и~характеризуется
свойствами этих элементов и~отношениями между ними, язык
исчисления предикатов является адекватным для описания объектов
и~классов объектов. Так. формализованные задачи оказываются
NP-полными или NP-трудными. Примером такой NP-трудной задачи
является задача анализа сложного объекта, представленного как
множество его элементов и~описываемого набором атомарных формул
с~предикатами, задающими свойства этих элементов и~отношения между
ними. Для решения данных задач рассматривается задача выделения
наибольшей общей с~точностью до имен переменных подформулы двух
элементарных конъюнкций атомарных предикатных формул. Выделение
таких подформул позволяет свести задачу распознавания объекта
к~серии аналогичных задач с~меньшей длиной исходных данных за счeт
построе\-ния многоуровневого описания классов, существенно
уменьшающего показатель степени в~экспоненциальной оценке числа
шагов решения NP-трудной задачи проверки при\-надлежности объекта
этому классу. Приводится алгоритм выделения наибольшей общей
с~точностью до имен переменных подформулы двух элементарных
конъюнкций. Доказываются оценки числа шагов его работы.
Анализируется время применения его реализации в~зависимости от
структуры исходных данных. Анализ числа шагов работы алгоритма
показывает, что предложенный алгоритм может быть успешно применен
для уменьшения вычислительной сложности многих задач
искусственного интеллекта, формализуемых средствами исчисления
предикатов. Приводятся результаты численных экспериментов,
показывающих влияние структуры исходных данных на время работы
алгоритма. Так, например, при увеличении количества аргументов
у~предикатов значительно снижается время работы за счeт уменьшения
глубины рекурсии. Также существенное влияние оказывает количество
различных предикатных символов, участвующих в~записи формулы. При
больших исходных данных особенно заметна эффективность
предложенного алгоритма, отсекающего <<ветви>>, заведомо не
приводящие к~успеху. Сильное влияние на время работы алгоритма
оказывает распределение переменных в~качестве аргументов
предикатов. Результаты показывают значительное снижение числа
шагов работы алгоритма при неравномерном распределении переменных.
В~процессе работы описанного алгоритма возникает задача проверки
совпадения с~точностью до имен переменных (изоморфизма) двух
элементарных конъюнкций. Решение этой задачи имеет наибольшую
вычислительную сложность среди прочих шагов алгоритма. Предложен
полиномиальный алгоритм проверки изоморфизма предикатных формул,
правильность работы которого превышает 99,5\%. Алгоритм не
является абсолютно точным. Доказано, что если он даeт
отрицательный ответ, то формулы не изоморфны. Если алгоритм дает
положительный ответ, то результаты численных экспериментов
в~99,5\% случаев показали изоморфность формул. Библиогр. 14~назв.
Табл.~2.

{\it Ключевые слова}: искусственный интеллект, исчисление
предикатов, алгоритмическая сложность, изоморфизм предикатных
формул.

\end{list}

}

\vskip3.0mm

\begin{list}{}{\leftmargin=7mm \rightmargin=7mm \listparindent=5mm}

\noindent{\it T. M. Kosovskaya, D. A. Petrov}

\vskip2mm \noindent{\bf EXTRACTION OF A MAXIMAL COMMON
SUB-FORMULA\\ OF PREDICATE FORMULAS FOR THE SOLVING\\ OF SOME
ARTIFICIAL INTELLIGENCE PROBLEMS}

\vskip2mm


{\footnotesize


\noindent St.~Petersburg State University, 7--9, Universitetskaya
nab., St.~Petersburg,\\ 199034, Russian Federation

\vskip2.0mm


\item If an investigated object in an Artificial Intelligence
problem is regarded as a set of its elements and is characterized
by properties of these elements and relations between them, then a
predicate calculus language is an adequate one for the description
of an object and classes of objects. Such a way formalized
problems are NP-complete or NP-hard. Example of such an NP-hard
problem is the problem of the analysis of a complex object
presented as a set of its elements and described by a set of
atomic formulas with the predicates setting properties of these
elements and relation between them. To solve such a problem, a
problem of extraction of a maximal common up to the names of
variables sub-formula of two elementary conjunctions of atomic
predicate formulas is under consideration in the paper. Extraction
of these sub-formulas allows us to reduce a recognition problem to
a series of analogous problems with the less input data length by
means of construction a level description of classes, which
essentially decreases an exponent in the exponential upper bound
for a number of solution algorithm steps for NP-hard problem of
checking whether an object belongs to this class. An algorithm of
extraction of a maximal common up to the names of variables
sub-formula of two elementary conjunctions of atomic predicate
formulas is presented in the paper. Bounds on number of the
algorithm run number of steps are proved. The time of its
implementation in dependence on the input data structure is
analyzed. The analysis of the number of algorithm steps shows that
the proposed algorithm may be successfully implemented in order to
decrease computational complexity of many Artificial Intelligence
problems which are formalized by means of predicate calculus. The
results of numerical experiments show the influence of input data
structure on the algorithm run time. For example, the increasing
of amount of predicate arguments involves essential decreasing of
the algorithm run time, which is a consequence of the recursion
depth decreasing. The number of different predicate symbols
occurred in the formula notation also essentially influences on
the algorithm run time. At larger input data the effectiveness of
the offered algorithm, cutting obviously unsuccessful
``brunches'', is especially noticeable. The strong impact on the
algorithm run time is exerted by distribution of variables as
arguments of predicates. Results show its considerable decreasing
at a nonuniform distribution of variables. During the described
algorithm run a problem of checking the coincidence up to the
names of variables (isomorphism) of two elementary conjunctions
appears. This problem has the greatest computational complexity
among the other problems arising on other steps of the algorithm.
A polynomial algorithm of checking whether two elementary
conjunctions of atomic predicate formulas coincide up to the names
of variables (are isomorphic) is offered. The algorithm is not a
precise one. The correctness of this algorithm implementation
exceeds 99,5\%. It is proved that if the algorithm gives a
negative answer then the formulas are not isomorphic. If the
algorithm gives a positive answer then the results of numerical
experiments show that 99,5\% pairs of formulas are isomorphic.
Refs~14. Tables~2.

\textit{Keywords}: Artificial Intelligence, predicate calculus,
algorithmic complexity, isomorphism of predicate formulas.


}

\end{list}


\vskip3mm

{\bf 1. Введение.} Формализация задач искусственного интеллекта
на~языке исчисления предикатов была предложена еще в~70-е годы XX
в. [1]. Пока теория сложности алгоритмов и, в~частности, понятие
NP-полной задачи, подробно описанной в~[2], не~получила широкого
распространения в~научной среде, полагали, что алгоритмы
автоматического доказательства теорем в~исчислении предикатов
позволят легко решать так называемые формализованные задачи. Но
многие из~них оказались NP-трудными [3] или даже в~общем случае
алгоритмически неразрешимыми (например, задача нахождения таких
воздействий на~объект, в~результате которых объект удовлетворяет
заданному целевому условию [4]).\newpage

При решении задач искусственного интеллекта часто используется
язык исчисления высказываний, позволяющий описывать и~распознавать
объекты, характеризующиеся конечным набором бинарных (или даже
конечнозначных) признаков. Данный подход к~решению задач
искусственного интеллекта получил название логико-алгебраического
[5]. При нем вычислительная сложность решения задач распознавания
полиномиальна относительно длины записи описания распознаваемого
объекта и~описаний классов~[6] и~имеет слабое отношение
к~NP-полной задаче ВЫПОЛНИМОСТЬ~[2], кроме того, что они обе
применяют язык пропозициональных формул.

Однако при распознавании сложного объекта (или выделении его
на~сложной сцене), который характеризуется не~своими глобальными
признаками, но~сам со\-стоит из~элементов, описывающихся набором
свойств и~отношениями между этими элементами, полезным оказывается
язык исчисления предикатов. Такой подход удобно называть
логико-предметным. В~частности, эти задачи имеют много общего
с~NP-полной задачей, относящейся к~базам данных, КОНЪЮНКТИВНЫЙ
БУЛЕВСКИЙ ЗАПРОС~[2].  При этом NP-трудность возникающих задач~[3]
вполне согласуется с~тем, что при моделировании их исходных данных
с помощью пропозициональных (булевых) переменных длина записи
новых описаний экспоненциально зависит от~длины записи исходных
данных при моделировании задачи с~помощью формул исчисления
предикатов~[7].

Анализ оценок сложности различных алгоритмов решения задач,
использующих формализацию на~языке исчисления предикатов, позволил
предложить многоуровневые описания классов, при определенных
условиях существенно уменьшающие число шагов решения таких
задач~[8]. Этот подход основан на~широко распространенном способе
выделения из~исходной задачи подзадач с~меньшей длиной записи
исходных данных.

Проблема заключалась в~том, что для построения предлагаемого
многоуровневого описания классов необходимо выделить достаточно
<<короткие подформулы>> исходных целевых формул. Однако они могут
не являться в~точности общими подформулами исходных формул,
но~станут таковыми после некоторой подстановки. Тогда мы будем
говорить об общей с~точностью до~имен переменных подформуле двух
предикатных формул, точнее, об изоморфных подформулах.

{\bf Определение 1.} {\it Две элементарные конъюнкции $A$ и~$B$
атомарных предикатных формул называются изоморфными, если
существуют такая элементарная конъюнкция $C$ и~такие подстановки
$\lambda_{A,C}$ и~$\lambda_{B,C}$ различных переменных из~формулы
$C$ вместо разных аргументов формул $A$ и~$B$ соответственно, что
результаты этих подстановок $A\lambda_{A,C}$ и~$B\lambda_{B,C}$
совпадают с~формулой $C$ с~точностью до~порядка литералов.}

{\it При этом подстановки $\lambda_{A,C}$ и~$\lambda_{B,C}$
называются унификаторами формул $A$ и~$B$ с~формулой $C$.}

Нетрудно видеть, что отношение изоморфизма формул есть отношение
эквивалентности.

Две формулы $A=p(a,b)~\&~p(b,a)~\&~q(b,a,c)$
и~$B=p(b,a)~\&~p(b,d)~\&~q(a,b,d)$ \mbox{имеют} подформулы,
изоморфные $C=p(u,v)~\&~q(v,u,w)$, которая с~точностью до~имен
переменных есть общая подформула формул $A$ и~$B$, так как при
замене переменных $u,v,w$ на~$a,b,c$ соответственно она
превратится в~$p(a,b)~\&~q(b,a,c)$~--- подформулу формулы $A$,
а~при замене переменных $u,v,w$ на~$b,a,d$~---
в~$p(b,a)~\&~q(a,b,d)$~--- подформулу формулы $B$. \sloppy{ }

\newpage Именно описанию алгоритма выделения наибольшей общей
с~точностью до имен переменных подформулы двух элементарных
конъюнкций атомарных предикатных формул и~построению общих
унификаторов (подстановок, в~результате которых эта <<подформула>>
действительно станет подформулами заданных формул) и~алгоритма
проверки изоморфности двух элементарных конъюнкций (дающего верный
результат более чем в~99.9\% случаев) посвящена настоящая статья.

%\bigbreak
{\bf 2. Постановка рассматриваемых задач.} Пусть
исследуемый объект представлен как множество своих элементов
$\omega = \{ \omega_1, \dots , \omega_t\}$. На~$\omega $ задан
набор предикатов    $p_1, \dots ,$ $ p_n$, характеризующих
свойства элементов $\omega $  и~отношения между ними. Логическим
описанием $S(\omega )$ объекта $\omega $ называется множество всех
атомарных формул или их отрицаний, истинных на~$\omega $.
Множество всех объектов разбито на~классы $\Omega =
\cup_{k=1}^K\Omega_k$. Логическим описанием класса $\Omega_k$
называется формула $A_k(\overline{x})$, заданная в~виде дизъюнкции
элементарных конъюнкций, такая что если $A_k(\overline{\omega})$
истинна, то~ $\omega\in \Omega_k$.

{Здесь и~далее посредством $\overline{x}$ обозначается список
элементов конечного множества $x$, соответствующий некоторой
перестановке номеров его элементов. Тот факт, что элементами
списка $\overline{x}$ являются элементы множества $y$, будем
записывать в~виде~\mbox{$x\subseteq y$.} }

С помощью построенных описаний объектов и~классов предлагается
решать сле\-дую\-щие задачи.

З а~д а~ч а~ и д е н т и~ф и~к~а ц и~и.~ {\it Проверить,
удовлетворяет ли объект $\omega$ или его часть описанию класса
$A_k(\overline{x})$, и~предъявить эту часть объекта.}

З а~д а~ч а~ к л а~с~с и~ф и~к~а ц и~и.~ {\it Найти все такие
номера $k$, что верна формула $A_k(\overline{\omega})$.}

З а~д а~ч а~ а н а~л и~з а.~ {\it Найти и~классифицировать все
части $\tau$ объекта $\omega$, для которых
$A_k(\overline{\tau})$.}

{Для того чтобы записать, что значения для переменных списка
$\overline{x}$, удовлетво\-ряю\-щие формуле $A(\overline{x})$,
различны, вместо формулы
$$\exists x_1 ... \exists x_m( \&_{i=1}^m \&_{j=i+1}^m (x_i\neq x_j) ~\&~
A(x_1,...,x_m))$$ будет использоваться обозначение $$\exists
\overline{x}_{\neq} A(\overline{x}).$$}

Решение задач идентификации, классификации и~анализа для
распознавания сложного объекта  сведено  в~[9] к~доказательству
соответственно логических следований
$$S(\omega)\Rightarrow \exists \overline{x}_{\neq} ~A_k(\overline{x}),\eqno(1)$$
$$S(\omega)\Rightarrow  \bigvee_{k=1}^M A_k(\overline{\omega}), \eqno(2)$$
$$ S(\omega)\Rightarrow \bigvee_{k=1}^M \exists \overline{x}_{\neq} ~A_k(\overline{x}).\eqno(3)$$


Строго говоря, в~формулах (1)--(3) вместо квантора существования
и~дизъюнкции следовало бы писать  <<при каких наборах различных
значений $\overline{x}$>> $(? \overline{x}_{\neq})$ и~<<при каких
значениях $k$>> $(?k_{k=1}^M)$ соответственно\newpage

$$S(\omega)\Rightarrow (? \overline{x}_{\neq}) ~A_k(\overline{x}),\eqno(1')$$
$$S(\omega)\Rightarrow  (?k_{k=1}^M )A_k(\overline{\omega}), \eqno(2')$$
$$ S(\omega)\Rightarrow (?k_{k=1}^M) (? \overline{x}_{\neq}) ~A_k(\overline{x}),\eqno(3')$$
но как переборный алгоритм, так и~алгоритмы построения вывода
в~исчислении предикатов (например, в~секвенциальном исчислении
предикатов или доказательстве методом резолюций для исчисления
предикатов) при доказательстве логических следований (1)--(3) не
только отвечают на~вопрос <<{\it существует ли ... ?}>>,
но~и~предъявляют значения для переменных [10].

Заметим, что для того чтобы уметь доказывать (1)--(3), достаточно
доказывать логическое следование
$$S(\omega)\Rightarrow \exists \overline{x}_{\neq} ~A(\overline{x}),\eqno(4)$$
где $A(\overline{x})$~--- элементарная конъюнкция атомарных формул
и их отрицаний. В~[6, 11] доказаны оценки числа шагов алгоритмов,
решающих задачу (4), а~также задачи \mbox{(1)--(3)}. Эти оценки
имеют экспоненциальный от~длины записи формулы $A(\overline{x})$
вид. Для алгоритма полного перебора в~показателе оценки находится
количество переменных формулы $A(\overline{x})$, а~для алгоритмов,
основанных на~построении вывода в~исчислении предикатов,~---
количество атомарных формул, входящих в~$A(\overline{x})$. Там же
доказана NP-полнота задач (1)--(3) и, следовательно, NP-трудность
задач ($1'$)--($3'$).

%\bigbreak
{\bf 3. Многоуровневое описание классов.} Рассматриваются объекты,
структура которых позволяет выделить достаточно простые их части
и~дать описание объекта в~терминах свойств этих частей и~отношений
между ними, что, в~частности, можно сделать, выделяя <<часто>>
встречающиеся подформулы $P_i^1(\overline{y}_i^1)$ формул
$A_k(\overline{x})$ <<небольшой сложности>>. При этом записывается
система равносильностей вида $ {p_i}^1(y_i^1) \Leftrightarrow
P_i^1(\overline{y}_i^1),$ где $ {p_i}^1$~--- новые предикаты,
которые будем называть предикатами первого уровня, а~переменные
$y_i^1$~--- новые переменные для списков исходных переменных,
которые будем называть переменными первого уровня.

Обозначим формулы, полученные из~$A_k(\overline{x}_k)$  путем
замены всех вхождений формул вида $P_i^1(\overline{y}_i^1)$
на~атомарные формулы $p_i^1(x_i^1)$ (при ${y}_i^1 \subseteq  x$)
посредством $A_k^1(\overline{x}_k^1)$. Здесь
$\overline{x}_k^1$~--- список всех переменных формулы
$A_k^1(\overline{x}^1)$, состоящий как из~некоторых (быть может
всех) исходных переменных формулы $A_k(\overline{x}_k)$, так
и~из~переменных первого уровня, появившихся в~формуле
$A_k^1(\overline{x}_k^1)$. Такие формулы $A_k^1(\overline{x}_k^1)$
можно рассматривать как описания классов в терминах предикатов
исходного (нулевого) и~первого уровней.

Описанием объекта $S^1(\omega)$ первого уровня назовем множество
всех атомарных формул вида $p_i^1(\omega_{ij}^1)$, для которых
истинна определяющая  подформула $P_i^1(\overline{\tau}_{ij}^1)$
при $\tau_{ij}^1 \subset \omega$, а~объект первого уровня
$\omega_{ij}^1$ представляет из~себя список исходных объектов
$\overline{\tau}_{ij}^1$.

Процедуру выделения <<часто>> встречающихся подформул
<<не\-большой сложности>> можно повторить с~формулами
$A_k^1(\overline{x}^1)$.

В результате построения составных предикатов (т. е. предикатов
различных уровней) и~многоуровневого описания классов исходное
множество описаний классов $\{ A_k(\overline{x}) \}$ может быть
записано с~помощью равносильной ей многоуровневой системы описаний
классов вида

$$ \left\{
\begin{array}{rcl}
   ~  & A_k^{L}(\overline{x}^L), & \\
   & & \\
  p_1^1(x_1^1)   & \Leftrightarrow & P_1^1(\overline{y}_1^1),\\
                  &\vdots & \\
  p_{n_1}^1(x_{n_1}^1)   & \Leftrightarrow & P_{n_1}^1(\overline{y}_{n_1}^1),\\
                  &\vdots & \\
  p_{i}^l(x_i^l)   & \Leftrightarrow & P_{i}^l(\overline{y}_i^l),\\
                  &\vdots & \\
  p_{n_L}^L(x_{n_L}^L)   & \Leftrightarrow & P_{n_L}^L(\overline{y}_{n_L}^L).\\

\end{array}
\right .  $$



В [8] доказаны оценки изменения числа шагов проверки (4) при
использовании двухуровневого описания классов и~приведены
модельные примеры, иллюстрирующие существенное уменьшение
показателя экспоненты при его использовании. Однако в~этой работе
применяется эвристическое выделение общих подформул для
по\-строения двухуровневого описания классов. В~[9] предложен
алгоритм построения многоуровневого описания класса по~обучающей
выборке, в~основе которого лежит понятие неполной выводимости.

%\bigbreak
{\bf4. Понятие неполной выводимости формулы.} Для распознавания
объектов с~неполной информацией в~[12] было введено понятие
неполной выводимости предикатной формулы.

Рассматривается задача проверки того, что из~истинности всех
формул множества $S(\omega)$ следует истинность $A(\overline{x})$
или некоторой ее максимальной подформулы
$\widetilde{A}(\overline{y})$ на~наборе различных констант
из~$\omega$, где список переменных $\overline{y}$ является
подсписком списка переменных $\overline{x}$.

Пусть  $a$ и~ $\widetilde{a}$~--- количества атомарных формул
в~элементарных конъюнкциях $A(\overline{x})$
и~$\widetilde{A}(\overline{y})$ соответственно, $m$
и~$\widetilde{m}$~--- количества предметных переменных
в~$A(\overline{x})$ и~ $\widetilde{A}(\overline{y})$
соответственно.

Числа $q$ и~$r$ вычисляются по~формулам
$q=\frac{\widetilde{a}}{a}$, $r= \frac{\widetilde{m}}{m}$
и~характеризуют степень совпадения формул $A(\overline{x})$
и~$\widetilde{A}(\overline{y})$. В~этом случае подформула
$\widetilde{A}(\overline{y})$  называется $(q,r)$-фрагментом
формулы $A(\overline{x})$. Она является максимальной подформулой
элементарной конъюнкции $A(\overline{x})$, если является ее
$(q,r)$-фрагмен\-том с~максимальным среди всех $(q,r)$-фрагментов
значением параметра $q$. То есть для $\widetilde{A}(\overline{y})$
справедливо $S(\omega)\Rightarrow \exists
\overline{y}_{\neq}\widetilde{A}(\overline{y})$, и~ни для какой
подформулы формулы $A(\overline{x})$ с~большим значением параметра
$q$ это следствие не~выполняется.


Параметр   $q$ характеризует, насколько информативен фрагмент,
содержащий лишь  $r$-ю часть переменных.

Задача нахождения максимального $(q,r)$-фрагмента формулы
$\widetilde{A}(\overline{y})$ при условии справедливости множества
постоянных атомарных формул $S(\omega)$ называется задачей
проверки неполной выводимости этой формулы.   В~[12]  приведен
один из~возможных алгоритмов ее решения.

%\bigbreak
{\bf 5. Нахождение наибольшей общей подформулы двух
формул.} Понятие неполной выводимости из~множества постоянных
атомарных формул или их отрицаний легко обобщается до~понятия
неполной выводимости двух элементарных конъюнкций.

Пусть $A(\overline{x})$ и~ $B(\overline{y})$~--- две элементарные
конъюнкции предикатных формул со~списками предметных переменных
$\overline{x}$ и~ $\overline{y}$ соответственно. Проверка неполной
выводимости $A(\overline{x})\Rightarrow_P \exists
\overline{y}_{\neq} B(\overline{y})$ заключается в~получении
максимального $(q,r)$-фрагмента $Q_{AB}(\overline{z})$ формулы
$B(\overline{y})$ и~такой подстановки $\lambda_{AQ}=
|^{\overline{z}}_{\overline{y}'}$ списка переменных
$\overline{y}'$ из~$\overline{y}$ вместо переменных списка
$\overline{z}$, что $Q_{AB}(\overline{y'})$ является максимальной
подформулой формулы $B(\overline{y})$, при этом
$A(\overline{x})\Rightarrow \exists \overline{y'}_{\neq}
Q_{AB}(\overline{y'})$.

Аналогично при проверке неполной выводимости
$B(\overline{y})\Rightarrow_P \exists \overline{x}_{\neq}
A(\overline{x})$ получаем максимальный $(q,r)$-фрагмент
$Q_{BA}(\overline{z})$ формулы  $A(\overline{x})$ и~подстановку
$\lambda_{BQ}= |^{\overline{z}}_{\overline{x}'}$ списка переменных
$\overline{x}'$ из~$\overline{x}$ вместо переменных списка
$\overline{z}$, что $Q_{BA}(\overline{y'})$ есть максимальная
подформула формулы $A(\overline{x})$, такая что
$B(\overline{y})\Rightarrow \exists \overline{x'}_{\neq}
Q_{BA}(\overline{x'})$.

Можно доказать, что формулы $Q_{AB}(\overline{y'})$
и~$Q_{BA}(\overline{x'})$ изоморфны. В~качестве максимальной (с
точностью до~имен переменных) общей подформулы двух элементарных
конъюнкций $A(\overline{x})$ и~ $B(\overline{y})$ можно взять
любую из~них. Обозначим эту подформулу посредством
$Q(\overline{z})$.

Найденные в~процессе проверки неполной выводимости подстановки
$\lambda_{AQ}$ и~$\lambda_{BQ}$ являются унификаторами формул $A$
и $B$ соответственно с~формулой $Q$.

%\bigbreak
{\bf 6. Описание алгоритма проверки неполной выводимости
двух формул.} Вначале введем некоторые обозначения.

Пусть проверяется неполная выводимость
$A(\overline{x})\Rightarrow_P \exists \overline{y}_{\neq}
B(\overline{y})$. Для краткости эти формулы будем обозначать $A$
и~$B$ соответственно. Литералами будем называть атомарные формулы
или их отрицания. Пусть
    ~$n$~--- число литералов в~формуле $A$;
    ~$k$~--- число литералов в~формуле $B$;
    ~$C(\overline{z})$~--- максимальная по~числу литералов найденная подформула на~текущем этапе работы алгоритма для краткости обозначим ee через~$C$;
    ~$r$~--- число литералов в~$C$;
    ~$S$~--- текущий частичный унификатор для формул $A$ и~$B$, т.~е. $S = |_{x'}^{y'},~x' \subset x,~y' \subset y$;
    ~$P$~--- множество литералов, являющихся литералами формулы $A$, которые не~выкинуты из~рассмотрения на~текущем шаге работы алгоритма;
    ~$L$~--- множество литералов, являющихся литералами формулы $B$, каждый из~которых графически совпадает с~каким-либо литералом формулы $A$ при текущем частичном унификаторе;
    ~$L'$~--- множество литералов, являющихся литералами формулы $B$, которые не~выкинуты из~рассмотрения на~текущем шаге работы алгоритма и~ могут быть включены в~$L$.
% ~\\

{\bf Алгоритм выделения максимальной с~точностью до~имен
переменных общей подформулы. }

1. Формула $C$ не~инициализирована, подстановка $S$ пуста,
множество $P$ сов\-па\-дает с~множеством литералов $A$, множество
$L'$ совпадает с~множеством литералов $B$, множество $L$ пусто.

2. При текущей подстановке $S$ проверяем, какие литералы из~$L'$
заведомо не~могут графически совпасть ни с~одним литералом
$A$~(например, $p_i(y_1, y_2, y_3)~|S = p_i(x_1,$ $y_2, y_3)$,
но~в~$A$ нет ни одного литерала с~предикатом $p_i$ без отрицания
и~первым аргументом которого является переменная $x_1$). Такие
литералы отбрасываются из~множества $L'$.

Также проверяем, какие литералы графически совпали с~одним
из~литералов формулы $A$. Их перемещаем из~множества $L'$ в~$L$.

3. При текущей подстановке $S$ проверяем, какие литералы из~$P$
не~могут быть выполнены (например, $p_i(x_1,x_2) \in P$, $S =
|_{x_2}^{y_3}$, но~в~$L'$ нет литералов с~предикатом $p_i$ без
отрицания, где вторым аргументом не~было еще ничего подставлено
или стояла $x_2$, т.~е. заведомо никакой литерал из~$L'$ не~может
графически совпасть c данным) и~удаляем такие литералы из~$P$.

4. Если количество литералов в~$L$ больше количества литералов
в~$C$, то~конъюнкцию литералов из~$L$ записываем в~$C$.

5. Если подстановка $S$ полная, т.~е. $S =
|_{\overline{x}}^{\overline{y}}$, то~переходим к~п.~8 (предыдущий
шаг рекурсии).

6. Если $|L| + |L'|<r$, то~переходим к~п. 8 (предыдущий шаг
рекурсии).

7. Каждый литерал из~$L'$ пытаемся последовательно унифицировать
с~каждым литералом из~$P$. Если унификация возможна, то~делаем
рекурсионный шаг --- переходим к~п.~2, при этом удаляя выбранный
литерал из~$P$, добавляя к~$S$ переменные, определяемые данной
подстановкой, также перемещаем литерал из~$L'$ в~$L$, если он
графически совпал с~одним из~литералов из~$P$.

8. Проверка аналогична п.~6. Если все возможные подстановки
перебраны, то~переходим к~п.~8 (предыдущий шаг рекурсии; если его
не~было, алгоритм заканчивает работу). В~противном случае
продолжаем перебор (переходим к~п.~7).


%\bigbreak
{\bf 7. Оценки числа шагов работы алгоритма выделения максимальной
с~точностью до~имен переменных общей подформулы.} Алгоритм
заканчивает работу за~конечное число шагов, так как число
литералов в~формулах $A$ и~$B$ конечно и~каждый шаг рекурсии
удаляет хотя бы один элемент как из~множества $L'$, так
и~из~множества~$P$.

На асимптотику работы алгоритма самое главное влияние оказывает
структура входных данных. В~худшем случае каждый шаг рекурсии
удаляет только по~фиксированному количеству $a$ элементов
из~множеств $L'$ и~$P$. Это возможно, например, в~случае, когда
каждая переменная встречается ровно в~двух литералах (если
переменная встречается только в~одном литерале, то~она не~зависит
от подстановок остальных переменных, и~для нее сразу можно
определить единственно верную подстановку, не~учитывая ее
вхождения при переборе), все предикаты в~формулах двухместные
и~все литералы равны с~точностью до~имен переменных. В~таком
случае число шагов работы алгоритма имеет порядок
$$O(\underbrace{(n \cdot k)\cdot((n-a)\cdot(k-a))\cdot \ldots \cdot ((n-
sa)\cdot(k- s a))}_{s~=~\min \{
\left\lfloor\frac{n}{a}\right\rfloor,~\left\lfloor\frac{k}{a}\right\rfloor
\} }) =O(n^s \cdot k^s). $$


В лучшем случае глубина рекурсии равна единице. Это возможно,
например,  когда $|\overline{x}| = |\overline{y}| = t$ и~все
предикаты $t$-местные. Тогда выбор единственной пары графически
совпадающих литералов определяет подстановку всех переменных.
В~данном случае число шагов работы алгоритма имеет порядок
$$O(n \cdot k \cdot (n \cdot k)) = O(n^2 \cdot k^2). $$


В среднем после каждого шага рекурсии количество литералов для
следующего рекурсивного шага будет уменьшаться в~$\alpha$ раз при
некотором $\alpha > 1$. В~таком случае число шагов работы
алгоритма (при условии, что $d=\log_{\alpha}(n \cdot k) $) имеет
порядок
$$O\left(\underbrace{n \cdot k \cdot \frac{n \cdot k}{\alpha} \cdot \frac{n \cdot k}{\alpha^2} \cdot \ldots \cdot 1}_{d~=~\log_{\alpha}(n \cdot k)}\right) =
O\left(\frac{(n \cdot k)^d}{\alpha^{\frac{d \cdot
(d+1)}{2}}}\right)=$$

$$ =~O\left(\frac{(n \cdot k)^{\log_{\alpha}(n \cdot k)}}{(n \cdot k)^{1/2~ \log_{\alpha}(n \cdot k)}}\right)=
 O\left((n \cdot k)^{1/2~ \log_{\alpha}(n \cdot k)
}\right) . $$


%\bigbreak
{\bf 8. Анализ зависимости работы алгоритма от~структуры входных
данных. } Описанный алгоритм был реализован на~языке
программирования C++. Все данные о~времени работы алгоритмов
относятся к~запуску без
распараллеливания на~компьютере с~процессором Intel B950 с~частотой 2.1 ГГц. Они получены в~результате сбора статистики после 50 запусков  алгоритма. %Время работы приведено в~секундах.

Для получения сравнительных результатов скорости работы алгоритма
выделения наибольшей общей (с точностью до~имен аргументов)
подформулы двух формул было проведено несколько запусков
на~наборах пар формул. Распределение переменных в~формулах было
случайным и~близко к~равномерному, т.~е. все переменные
встречались в записи формулы примерно одинаковое число раз,
во~всех формулах был использован один и~тот же предикатный символ
(без отрицания), если не~оговорено противное.

На число шагов работы данного алгоритма оказывает серьезное
влияние структура входных данных. Существует зависимость числа
шагов работы алгоритма от~количества аргументов предикатов,
входящих в~исходные формулы.
%   \\

    Параметры формул: 25 литералов, 12 переменных, 1 предикатный символ. %\\

\begin{center}
{\footnotesize

    \begin{tabular}{lcc}
    Количество аргументов у~предиката\,\!...  &4 & 5   \\
 Время, с   &&\\
~~~минимальное \!\!......................................    & 0.146 &  0.0478 \\
~~~среднее\;\!...............................................      & 0.217  & 0.0518 \\
~~~максимальное \!....................................    & 0.269 & 0.0655 \\
    \end{tabular} %~\\[0.5cm]
}

\end{center}    %\par

Результаты показывают значительное снижение числа шагов работы
алгоритма при увеличении количества аргументов предиката. Это
является следствием уменьшения глубины рекурсии в~процессе
перебора множеств литералов во~время работы алгоритма. Также
существенное влияние оказывает количество различных предикатных
символов, участвующих в~записи формулы.
%  \\

Параметры формул: 25 литералов, 12 переменных, количество
аргументов у~предикатов 3.

\begin{center}
{\footnotesize

\begin{tabular}{lcc}
    Количество различных предикатных символов\,...  &2 & 3   \\
 Время, с   &&\\
~~~минимальное \!\!........................................................    & 0.452  &  0.083 \\
~~~среднее\;\!.................................................................      & 0.723  & 0.164  \\
~~~максимальное \!......................................................    &1.131 &0.352 \\
    \end{tabular} %~\\[0.5cm]
}

\end{center}    %\par

При больших исходных данных особенно заметна эффективность
предложенного алгоритма, отсекающего <<ветви>>, заведомо
не~приводящие к~успеху (пп. 2 и~3 алгоритма) по~сравнению
с~алгоритмом полного перебора всех возможных вариантов. Так,
например, для алгоритма полного перебора соответствующие величины
были следующими:

\begin{center}
{\footnotesize

\begin{tabular}{lc}
    Количество различных предикатных символов\,...  & 3   \\
 Время, с  &\\
~~~минимальное \!\!........................................................    &7.914 \\
~~~среднее\;\!.................................................................      & 12.078  \\
~~~максимальное \!......................................................    &18.321 \\
    \end{tabular} %~\\[0.5cm]
}

\end{center}    %\par

Выбор предикатных символов во~время запуска случаен, все
предикатные символы встречались в~записи формулы примерно равное
количество раз. Результаты показывают существенное снижение числа
шагов работы алгоритма при увеличении количества различных
предикатных символов в формулах. Данный факт является следствием
увеличения эффективности отброса <<ветвей>> во~время процесса
перебора множеств литералов, так как наличие нескольких
предикатных символов, в~определенном смысле, разбивает процесс
поиска на~подзадачи меньшей размерности. Также немаловажный фактор
для изменения времени работы алгоритма --- это распределение
переменных в~записи формулы. Все вышеприведенные результаты
получены с~учетом равномерного распределения переменных, т. е.
с~равным в~среднем числом вхождений переменных в~формулу
(табл.~1).



\vskip 2mm
\begin{center}
{\small

{\it Таблица 1.} {\bf Зависимость времени от~распределения
переменных}

}

\vskip 3mm

{\footnotesize

    \begin{tabular}{|l|c|c|c|}
    \hline
\multicolumn{1}{|c|}{} & \multicolumn{3}{c|}{Время, с}\\
%\hhline{|~|---|}
\cline{2-4}
\multicolumn{1}{|c|}{\raisebox{5pt}[1pt]{Распределение переменных}   }   & минимальное & среднее & максимальное \\

    \hline
%    &&&\\
    Равномерное & 0.156 & 0.213 & 0.261 \\
    Нормальное с~параметрами (6, 2) & 0.047 & 0.056 & 0.065 \\
    \hline
    \end{tabular}

}
\end{center}

 Параметры формул: 25 литералов, 12 переменных, 1 предикатный
символ, количество аргументов у~предикатов 3.

    Нормальное распределение переменных следует воспринимать с~учетом
нумерации переменных вида $x_i$, в~данном случае $i$ меняется от~0
до~11, т. е. наибольшее число вхождений в~среднем у~переменной
$x_6$ меньше, чем у~$x_5,~ x_7$ и~т.~д. Результаты показывают
значительное снижение числа шагов работы алгоритма при
неравномерном распределении переменных. Данный факт также является
следствием более эффективного избавления от~<<ветвей>> в~процессе
перебора множеств литералов.
    \par
    Суммируя все замечания касательно структуры входных данных, можно
добиться существенно более эффективного использования данного
алгоритма (табл.~2).


\vskip 2mm
\begin{center}
{\small

{\it Таблица 2.} {\bf Зависимость времени от~структуры входных
данных}

}

\vskip 3mm

{\footnotesize

    \begin{tabular}{|c|c|c|c|}
    \hline
 & \multicolumn{3}{|c|}{Время, с}\\
%\hhline{|~|---|}
\cline{2-4}
\raisebox{5pt}[1pt]{Тип формул}     & минимальное & среднее & максимальное \\
    \hline
%    &&&\\
   1 & 7.914 & 12.078 & 18.321 \\
  2 & 11.04 & 16.85 & 34.53 \\
    \hline
    \end{tabular}

}
\end{center}

 Формулы типа 1: 25 литералов, 12 переменных, 1 предикатный
символ, количество аргументов у~предикатов 3; равномерное
распределение переменных.

    Формулы типа 2: 100 литералов, 40 переменных, 6 предикатных
символов, количество аргументов у~предикатов 5; нормальное
распределение с~параметрами~(20,~6).



    Таким образом, несмотря на~увеличение длины записи входных данных в~4
раза (алгоритм имеет экспоненциальные оценки числа шагов работы
от~длины записи входных данных), за~счет использования информации
о~зависимости алгоритма от~структуры входных данных удалось
сохранить время работы на~прежнем уровне.


{\bf 9. Алгоритм проверки изоморфности элементарных конъюнкций
атомарных предикатных формул. } При построении многоуровневого
описания классов большое значение имеет проверка изоморфности двух
элементарных конъюнкций. Эта задача близка к~так называемой
<<открытой>> задаче проверки изоморфизма графов, для которой
неизвестен полиномиальный алгоритм и~не доказано, что она
NP-полна.

Предложим полиномиальный алгоритм, который по~результатам
численных экспериментов дает правильный ответ более чем в~99.5\%
случаев. Полученную оценку числа шагов этого алгоритма можно
назвать генерической сложностью задачи [13].

{\bf Определение 2.}   {\it  Характеристикой переменной $v$
в~формуле $A$ для литерала $L_i,~\chi(v)_{L_i}^A$,  {называется
упорядоченный набор $(e_1, e_2, ... , e_q)$, где $q$ ---
количество переменных литерала $L_i$,
 $e_j$ --- количество атомарных формул с~тем же предикатом,
что и~в~литерале $L_i$, в~которых переменная $v$ является $j$-м
аргументом.}}

{\bf Определение 3.}
     {\it    Полной характеристикой переменной $v$ в~формуле
     $A,~\chi(v)^A$,
 называется упорядоченный набор $(\chi(v)_{L_1}^A, ... ,
\chi(v)_{L_i}^A, ... , \chi(v)_{L_n}^A)$, где $L_i$ пробегает
по~всем литералам формулы $A$.}

 З а~м е ч а~н и~е.
        Стоит заметить, что равенство полных характеристик переменных
$\chi_1(v)^A =$ $ (\chi_1(v)_{L_1}^A, ... , \chi_1(v)_{L_i}^A, ...
, \chi_1(v)_{L_n}^A)$ и~$\chi_2(u)^A = (\chi_2(u)_{{L'}_1}^A, ...
 , \chi_2(u)_{{L'}_i}^A,$ $... ,$ $\chi_2(u)_{{L'}_n'}^A)$ влечет
за~собой равенство множеств литеральных символов $\{L_1, ... ,
L_n\}$ и~$\{{L'}_1, ... , {L'}_{n'}\}$.


{\bf Определение 4.} {\it    Множеством характеристик формулы $A$,
$\chi(A)$, называется мультимножество $\{~ \chi(v_k)^A ~\}$, где
$v_k$ пробегает множество всех переменных формулы $A$}.


    {\bf Обозначения: }

     $\bullet$ исходные формулы $A(\overline{x})$ и~$B(\overline{y})$ соответственно;

    $\bullet$ $k_A$ и~$k_B$ --- количество различных предметных переменных
в формулах соответственно;

    $\bullet$ $n_A$ и~$n_B$ --- количество литералов в~формулах соответственно;

    $\bullet$ $l_A$ и~$l_B$ --- количество разных предикатных символов в~формулах соответст\-венно.

{\bf Алгоритм проверки равенства характеристик. }

    1. Если $k_A \neq k_B$, или $n_A \neq n_B$, или $l_A \neq l_B$,
то алгоритм возвращает отрицательный ответ, иначе п.~2.

    2. Если $\chi(A) \neq \chi(B)$, то~алгоритм возвращает
отрицательный ответ, в~противном случае алгоритм возвращает
положительный ответ.

    Важно отметить, что алгоритм не~является абсолютно точным. В~большинстве случаев положительный результат работы алгоритма
означает равенство формул. В~п. 10 будут приведены статистические
оценки этого факта. В~случае возврата отрицательного ответа
результат работы алгоритма абсолютно верен.

{\bf Теорема.} {\it    Если алгоритм проверки равенства
предикатных формул возвращает отрицательный ответ, то~формулы $A$
и $B$ не~равны.}

   Д о~к~а з а~т е л ь с~т в~о.
    Очевидно, что формулы не~равны в~случае возврата отрицательного
ответа при выполнении п.~1 алгоритма. Рассмотрим возврат из~п.~2.

    Предположим противное --- формулы $A$ и~$B$ равны. С~одной стороны, неравенство множеств $\chi(A)$ и~$\chi(B)$ означает, что в~множестве $\chi(A)$
есть по~крайней мере одна полная характеристика переменной (не
уменьшая общности, обозначим ее через $\chi(x)^A$), которой нет
в~$\chi(B)$; с~другой --- равенство формул $A$ и~$B$ означает, что
существует такая подстановка переменных $S =
|_{\overline{y}}^{\overline{x}}$ и~такая перестановка литералов
в~записи конъюнкции формулы $A$, что в~результате формула $A$
графически совпадет с~формулой $B$. Следовательно, с~помощью
описанных операций была изменена полная характеристика
$\chi(x)^A$. Однако данные операции не~могут изменить число
вхождений переменной в~предикаты или символы предикатов, одним
из~аргументов которых является переменная. \hfill \rule{5pt}{5pt}

    Однако из~равенства множеств характеристик двух предикатных
формул не~следует равенство самих формул.

   {\bf Пример.}
 $$   A(\overline{x}) = p_1(x_3, x_0, x_2)~\&~p_1(x_1, x_3,
x_0)~\&~p_1(x_2, x_1, x_3), $$
 $$   B(\overline{y}) = p_1(y_3, y_0, y_2)~\&~p_1(y_1, y_2,
y_0)~\&~p_1(y_2, y_1, y_3).$$
   Нетрудно видеть, что формулы не~изоморфны, но их множества
характеристик
  $$  \chi(A) = \{ \chi(x_0)^A, \chi(x_1)^A, \chi(x_2)^A, \chi(x_3)^A \} =$$
   $$ = \{~(\chi(x_0)_{p_1}^A ), (\chi(x_1)_{p_1}^A ),
(\chi(x_2)_{p_1}^A ), (\chi(x_3)_{p_1}^A ) ~\} = $$
 $$   = \{~((0, 1, 1)), ((1, 1, 0)), ((1, 0, 1)), ((1, 1, 1))~\}, $$%~\\~
$$    \chi(B) = \{ \chi(y_0)^B, \chi(y_1)^B, \chi(y_2)^B, \chi(y_3)^B \} = $$
 $$   = \{~(\chi(y_0)_{p_1}^B ), (\chi(y_1)_{p_1}^B ),
(\chi(y_2)_{p_1}^B ), (\chi(y_3)_{p_1}^B ) ~\} = $$
$$    = \{~((0, 1, 1)), ((1, 1, 0)), ((1, 1, 1)), ((1, 0, 1))~\}$$
 совпадают.

{\bf 10.   Оценки числа шагов алгоритмa проверки изоморфности
формул.}
    Основной этап алгоритма заключается в~построении множества
характеристик формул и~проверки их на~равенство. Для построения
данных множеств нужно просмотреть все литералы соответствующих
формул и~посчитать число вхождений переменных в~них. Этот этап
занимает порядка $O(n \cdot d)$ шагов, где $n$ --- число литералов
в формуле, $d = \max_{i=1,\dots,n} \{ |L_i| \}$, $L_i$ --- литерал
с предикатным символом $p_i$. Далее следует проверка равенства
полученных множеств характеристик.  Она требует порядка $O(k^2)$
шагов, где $k$
--- число различных переменных в~формулах. Таким образом, число шагов
работы всего алгоритма имеет порядок
    %\begin{equation}
$   O(n \cdot d + k^2).$
  %  \end{equation}
    %\par

    Для получения статистических оценок равенства самих формул при
равенстве множеств характеристик двух формул были проведены
численные расчеты. Производились запуск данного алгоритма
и~проверка корректности его работы с~помощью алгоритма выделения
наибольшей общей подформулы с~точностью до~имен аргументов. Для
этого использовались пары формул с~числом переменных от~3 до~7,
с~числом литералов от~3 до~10 и~с~размерностью предикатов от~3
до~5 (в обеих формулах эти числа совпадали). Число переменных
всегда было больше размерности предикатов. Указанные числа
выбирались случайным образом, также распределение переменных
в~формулах было случайным и~было близко к~равномерному. После
проверки $10^6$ данных пар формул было получено, что только
в~$0.038\%$ случаях имеет место быть ложноположительный результат
работы алгоритма. Таким образом, точность алгоритма составляет
примерно $ 99.95\%$.


{\bf  11. Заключение.} Исходя из~оценок числа шагов работы
алгоритма, можно сделать вывод, что для решения  задачи выделения
наибольшей общей с~точностью до~имен переменных подформулы двух
элементарных конъюнкций может быть успешно применен данный
алгоритм. Требует дальнейшего исследования зависимость числа шагов
работы алгоритма от~вида входных данных. По-видимому, оказы\-вает
сильное влияние распределение переменных в~качестве аргументов
предикатов. В~соот\-ветствии с~этим отметим, что возможно
усовершенствование алгоритма на~этапе выбора литералов из~множеств
$P$ и~$L'$. К~тому же такой алгоритм не~вводит порядок перебора
возможных подстановок: это не~оказывает сильного влияния на~время
его работы с~более <<равномерными>>  данными, но, скорее всего,
будет играть значительную роль в~случае, когда некоторые
переменные будут на~порядок чаще встречаться в~предикатах, чем
другие. Также возможен эвристический вариант алгоритма,
ограничивающий глубину рекурсии или множество выбираемых литералов
для следующего шага рекурсии.

Также требует дальнейшего изучения алгоритм проверки изоморфизма
формул. Возможны классификация случаев ложноположительного
результата работы и~доработка алгоритма, исходя из~полученных
данных.

 Алгоритм может быть применен при исследовании сложных составных объектов, описание которых строится на~основе свойств их элементов и~отношений между ними. В~частности, он важен при решении таких задач:

---\,\,введение метрики в~множестве описаний объектов на~языке исчисления предикатов [15];

---\,\,построение многоуровневого описания классов объектов [8], существенно уменьшающее время распознавания сложного составного объекта и~позволяющее производить параллельные вычисления;

---\,\,построение самообучающейся логико-предикатной сети, которая во~время обучения может изменять свою конфигурацию [14], в~отличие от~классической нейронной сети, конфигурация которой задается изначально.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\input{03/lit-ra}

%%%%%N DOI в~ссылке!!!!!!!!!!

\input{03/ref-s}

%%%%%N DOI в~ссылке!!!!!!!!!!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\footnotesize




%\thispagestyle{empty}

\vskip 3mm

%\thispagestyle{empty}


\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
\fancyfoot[LO]{\footnotesize{\rm{Вестник~СПбГУ.~Прикладная~математика.~Информатика...~\issueyear.~Т.~13.~Вып.~\issuenum}}
\hfill}%
\fancyfoot[RE]{\hfill\footnotesize{\rm{Вестник~СПбГУ.~Прикладная~математика.~Информатика...~\issueyear.~Т.~13.~Вып.~\issuenum}}}%
%\lhead{} %верхний колонтитул слева
%%\rhead{} % верхний колонтитул справа
% для оформления нижнего колонтитула
\cfoot{} %
%\lfoot{} %
%\rfoot{\thepage} %


\noindent Статья рекомендована к~печати проф. Л.\,А.~Петросяном.

\vskip 1mm

\noindent Статья поступила в~редакцию 30 сентября 2016~г.

\vskip 1mm

\noindent Статья принята к~печати 8 июня 2017~г.

}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\vskip 5mm


%{\footnotesize

%\noindent К\,о\,н\,т\,а\,к\,т\,н\,а\,я\,
%и\,н\,ф\,о\,р\,м\,а\,ц\,и\,я \nopagebreak

%\vskip 3mm

%\textit{Буре Артем Владимирович}~--- аспирант; e-mail:
%bure.artem@gmail.com

%\vskip 2mm

%\emph{Bure Artem Vladimirovich}~--- post-graduate student; e-mail:
%bure.artem@gmail.com

%}
