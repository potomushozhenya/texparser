


{\small

\noindent $\issueyear$
\emph{ВЕСТНИК\,САНКТ-ПЕТЕРБУРГСКОГО\,УНИВЕРСИТЕТА Сер.\,10}
Вып.\,$\issuenum$\linebreak

}

%\ \\ \vskip 0.8mm\hrule \\ \hrule \\ \ \\

\vskip -2.5mm

\hline\vskip .5mm

\hline

\vspace{1.2cm} \noindent {\large ПРИКЛАДНАЯ МАТЕМАТИКА}
\vspace{1.0cm}

\noindent{\footnotesize УДК 004.056.3}

\vskip3mm

\noindent{\it А.~В.~Маров, А.~Ю.~Утешев}

\vskip4mm

\noindent{\bf МАТРИЧНЫЙ ФОРМАЛИЗМ КОДОВ РИДА---СОЛОМОНА}

\efootnote{

\vspace{-3mm}\parindent=7mm


%{\copyright} Н. А. Валиотти, 2014

{\it Маров Алексей Валерьевич}~--- аспирант, разработчик
исследовательской лаборатории, Raidix; alekseymmm@mail.ru

{\it Утешев Алексей Юрьевич}~--- доктор физико-математических
наук, профессор; alexeiuteshev@ gmail.com



\vskip 2.0mm

\textit{Marov Alexei Valer'evich}~--- postgraduate student,
software developer in R\&D Lab, Raidix; alekseymmm@mail.ru

\textit{Uteshev Alexei Yur'evich}~--- doctor of physical and
mathematical sciences, professor; alexeiuteshev@ gmail.com

{\copyright} Санкт-Петербургский государственный университет,
2016\\
%$^{*}$ Работа выполнена при финансовой поддержке
%Санкт-Петербургского государственного университета (грант
%№~9.38.673.2013).
}

\vskip4mm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
%\fancyfoot[LO]{{\footnotesize\emph{\doivyp09 } }\hfill\thepage}%
\fancyfoot[LO]{{\footnotesize\emph{\doivyp/spbu10.\issueyear.\issuenum01 } }\hfill\thepage}%
%\fancyfoot[RE]{\thepage\hfill{\footnotesize\emph{\doivyp09 } } }%
\fancyfoot[RE]{\thepage\hfill{\footnotesize\emph{\doivyp/spbu10.\issueyear.\issuenum01}}}%
%\fancyfoot[LO]{\hfill{\fontsize{10.5}{10.5}\selectfont \thepage}}%
%\fancyfoot[RE]{{\fontsize{10.5}{10.5}\selectfont \thepage}\hfill}%
%\lhead{} %верхний колонтитул слева
%%\rhead{} % верхний колонтитул справа
% для оформления нижнего колонтитула
\cfoot{} %
%\lfoot{} %
%\rfoot{\thepage} %



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\footnotesize

\noindentСанкт-Петербургский государственный университет,
Российская Федерация, \\ 199034, Санкт-Петербург, Университетская
наб., 7--9



\vskip3mm

\begin{list}{}{\leftmargin=7mm \rightmargin=7mm \listparindent=5mm}

\item Предлагаются модификации алгоритмов кодирования и~исправления ошибок
(отказов и~скрытых повреждений), используемых в~кодах
Рида---Соломона. Эти модификации используют матричный формализм
и~основаны на~алгоритме обращения матрицы Вандермонда Для матрицы
$ V=\left[ \lambda_j^{i-1} \right]_{i,j=1}^{n} $ предлагаемый
алгоритм вычисляет столбцы $ V_{[1]}^{-1},\dots, V_{[n-1]}^{-1},
V_{[n]}^{-1} $  матрицы $ V^{-1} $  рекурсивно, начиная
с~последнего, по~формулам
$$ V_{[n]}^{-1}=\Xi_0,\ V_{[j]}^{-1}=\Xi_{n-j}- \sigma_1  V_{[j+1]}^{-1} - \sigma_2  V_{[j+2]}^{-1}- \dots - \sigma_{n-j}  V_{[n]}^{-1} ,~ \ j=n-1,n-2,\dots,1 ,
$$
где $ \Xi_k=\left[\lambda_1^k/W^{\prime}(\lambda_1),\dots,
\lambda_n^k/W^{\prime}(\lambda_n) \right]^{\top}, \sigma_k =
\sum_{j=1}^n \lambda_j^{n+k-1}/W^{\prime}(\lambda_j) $, $
k=\overline{1,n} $, а~$ W(x)=\prod_{k=1}^n (x-\lambda_k) $.
Полученный результат предлагается использовать для реализации
систематического кодирования вектора из~$ n $ информационных
блоков посредством операции умножения (в подходящем поле Галуа)
его на~матрицу $ \mathbf K=[\widetilde{W_i}(a^{N-j-1})],
i=\overline{1,m}, j=\overline{0,n-1} $. Здесь $ \widetilde{W_\ell}
(x),\ell=\overline{1,m} $, означают базовые интерполяционные
полиномы Лагранжа, порожденные степенями примитивного элементами
поля, а~$ m $ --- количество служебных блоков (синдромов). В~этой
же идеологии  реализуется и~процедура исправления ошибок.
Программная реализация на~языке~C демонстрирует рост
производительности в сравнении с~известными специализированными
программными продуктами, а~также допускает возможность
параллелизации. Библиогр. 17~назв. Ил.~1.

{\it Ключевые слова}: помехоустойчивое кодирование, коды
Рида---Соломона, матрица Вандермонда.

\end{list}

}

%\newpage
\vskip2.0mm

\begin{list}{}{\leftmargin=7mm \rightmargin=7mm \listparindent=5mm}

\noindent{\it  A.~V.~Marov, A.~Yu.~Uteshev}

\vskip2mm\noindent{\bf MATRIX FORMALISM OF THE REED---SOLOMON
CODES}

\vskip1.5mm



{\footnotesize

\noindent St.~Petersburg State University, 7--9, Universitetskaya
nab.,\\ St.~Petersburg, 199034, Russian Federation

\vskip2mm


\item The paper is focused onto modification of the involved algorithms of coding and error (i.~e., failures and %\linebreak\newpage\noindent
silent data corruptions) correction in the Reed---Solomon codes. These modifications involve matrix formalism and are based on an algorithm for the
Vandermonde matrix inversion. For such a matrix $ V=\left[
\lambda_j^{i-1} \right]_{i,j=1}^{n} $ the suggested algorithm
computes the columns $  V_{[1]}^{-1},\dots, V_{[n-1]}^{-1},
V_{[n]}^{-1} $ of the matrix $ V^{-1} $  recursively, starting
from the last column, via the formulas
$$ V_{[n]}^{-1}=\Xi_0,\ V_{[j]}^{-1}=\Xi_{n-j}- \sigma_1  V_{[j+1]}^{-1} - \sigma_2  V_{[j+2]}^{-1}- \dots - \sigma_{n-j}  V_{[n]}^{-1} ,~ \ j=n-1,n-2,\dots,1 \, .
$$
Here $ \Xi_k=\left[\lambda_1^k/W^{\prime}(\lambda_1),\dots,
\lambda_n^k/W^{\prime}(\lambda_n) \right]^{\top}, \sigma_k =
\sum_{j=1}^n \lambda_j^{n+k-1}/W^{\prime}(\lambda_j) $, $
k=\overline{1,n} $, and $ W(x)=\prod_{k=1}^n (x-\lambda_k) $. The
obtained result is applied for realization of systematic coding of
the $ n $-vector of the information blocks with the aid of
multiplication (in an appropriate Galois field) by the matrix $
\mathbf K=[\widetilde{W_i}(a^{N-j-1})],\ i=\overline{1,m},\
j=\overline{0,n-1} $. Here $ \widetilde{W_\ell} (x),\
\ell=\overline{1,m} $, denote the basic Lagrange interpolation
polynomials generated by the powers of a primitive element of the
field, while $ m $ stands for the number of redundancy blocks
(syndromes). In the framework of this ideology, an error
correcting procedure is also realized. The program implementation
in C demonstrates  high performance results (compared to existing
software) with solid perspectives for parallelization. Refs~17.
Fig~1.

\textit{Keywords}: error-correcting codes, Reed---Solomon codes,
Vandermonde matrix.


}

\end{list}

\vskip 2.5mm



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\bf 1. Введение.} Рост объемов информации, хранимой
человечеством, за~последние годы увеличился настолько, что
в~системах хранения данных (СХД) стали использовать не~отдельные
накопители (<<жесткие диски>>), но~массивы накопителей. Наряду
с~требованиями, предъявляемыми к~скорости записи и~чтения,
существенным яв\-ляется и~обеспечение отказоустойчивости  таких
массивов. Для последней задачи при\-ме\-няют\-ся различные
алгоритмы помехоустойчивого кодирования. Изначально они
разрабатывались для каналов передачи данных и~требовали
значительных вычисли\-тельных ресурсов при кодировании
и~декодировании. Широко распространенные в~настоящее время
технологии хранения данных, известные как RAID (Redundant Array of
Independent Disks), также изначально использовали
специализированное оборудование (ASIC контроллеры) для кодирования
и декодирования. Однако дороговизна разработки и~производства
такого оборудования сформировала потребность организации процедуры
кодирования с~помощью процессоров общего назначения. Поэтому
актуальной стала задача повышения скорости процессов кодирования
за счет оптимизации алгоритмов и~их реализаций в~RAID.


Каждый  RAID массив представляет собой набор жестких дисков,
воспринимае\-мых внешней системой как единое целое. Для повышения
надежности массивов на~них записываются и~хранятся не~только
информационные данные, но~и некото\-рая избыточная информация
(синдромы), которая позволяет восстанавливать данные в~случае их
частичной утраты. Синдромы рассчитываются  на~этапе кодирования,
а~их использование для контроля целостности и~восстановления
утраченных данных производится на~этапе декодирования. Различают
два типа потери данных. Первый связан с~выходом из~строя одного
блока, расположение которого обнаруживается системами технического
(аппаратного) контроля. В~этом случае место утраты данных известно
и говорят об \emph{отказе} блока (failed block или failure).
Во~втором случае данные ис\-ка\-жают\-ся в~процессе записи,
хранения или чтения, но~системы аппаратного контроля не~выявляют
ошибки (ни самого факта ее присутствия, ни~ее местоположения).
В~таком случае говорят о~\emph{скрытом повреждении данных} (silent
data corruption, SDC).

Различные подходы к~восстановлению нескольких отказов описаны
в~работах [1, 2]. Их суть заключается в~применении матрицы Коши
или матрицы Вандермонда в~качестве матрицы кодирования. Алгоритм
обнаружения и~исправления одного скрытого повреждения
рассматриваeтся в~статье [3], но~излагаемый в~ней
подход\linebreak\newpage\noindent не~позволяет исправлять большее
количество скрытых повреждений. В~последние годы были разработаны
и  другие коды, такие как регенерирующие (Regenerating codes)~[4],
LRC~[5], а~также пирамидальные [6]; все они нацелены на~уменьшение
количества блоков, которые необходимо прочитать, чтобы
восстановить отказавший блок.

В случае необходимости восстановления большого количества отказов
и скрытых повреждений универсальным решением  являются коды
Рида---Соломона (РС-коды). Основное их преимущество заключается
в~обеспечении высокой степени отказоустойчивости при минимальной
избыточности, благодаря чему они очень популярны в~СХД.
Математические основы этих кодов и~практические рекомендации по~их
использованию  описаны в~монографиях [7--9]. Следует заметить, что
с~учетом изменения архитектуры процессоров со~временем многие
задачи, описанные в~[7--9], потеряли свою актуальность или нашли
новые решения (см., например, [10, 11]). Однако же некоторые
особенности остаются еще узкими местами в~практике применения
РС-кодов. Одну из~таких сложностей представляет алгоритм
кодирования и~декодирования, основанный на~операциях с~полиномами
над конечными полями. Существует несколько способов оптимизации
расчетов РС-кодов, например основанный на~применении быстрого
преобразования Фурье [12].

В настоящей работе предлагается новый подход к~РС-кодам,
использующий матричный формализм, в~том числе алгоритм обращения
матрицы Вандермонда.\linebreak Статья организована следующим
образом. В~п.~2 изложен алгоритм обращения матрицы Вандермонда.
В~п.~3 кратко описан стандартный способ построения
систематического РС-кода, а~в~п.~4  --- предлагаемый авторами
матричный вариант алгоритмов кодирования и~исправления ошибок.
В~п. 5 приведены результаты сравнения производительности этого
варианта с~реализациями помехоустойчивых кодов из~популярных
специализированных библиотек.

{\bf 2. Обращение матрицы Вандермонда.} Для наглядности изложим
здесь результаты в~терминологии бесконечных полей, хотя в~п. 3--5
они будут использованы исключительно только для  полей конечных.

Пусть задан набор различных элементов $ \{
\lambda_1,\dots,\lambda_n \} $ поля. Будем называть матрицу вида
\begin{equation*}
V_{m,n}(\lambda_1, \lambda_2,\ldots,\lambda_n) = \left(
\begin{array}{llll}
    1& 1& \ldots& 1\\
    \lambda_1& \lambda_2& \ldots& \lambda_n\\
    \lambda_1^2& \lambda_2^2& \ldots& \lambda_n^2\\
    \vdots& \vdots&  & \vdots \\
    \lambda_1^{m-1}& \lambda_2^{m-1}& \ldots& \lambda_n^{m-1}
\end{array}
\right)
\end{equation*}
$ (m,n) $-матрицей Вандермонда.

Нас прежде всего интересуют способы обращения квадратной матрицы
Вандермонда $ V_{n,n}(\lambda_1, \lambda_2,\ldots,\lambda_n) $;
для краткости будем обозначать ее просто $ V $. С~этой целью
рассмотрим полиномы%
\vspace*{-2mm}%
$$ W(x) = \prod_{j=1}^n
(x-\lambda_j) ,\quad W_j(x) = \frac{W(x)}{x-\lambda_j}, \quad
j=\overline{1,n} \ ,   $$
\vspace*{-2mm}%
\noindentи вычислим набор базовых интерполяционных полиномов
Лагранжа\\
\begin{equation}
\widetilde W_j(x)
=\frac{W_j(x)}{W_j(\lambda_j)}=\frac{W_j(x)}{W^{\prime}(\lambda_j)}=
w_{j0}+w_{j1}x+\dots+w_{j,n-1}x^{n-1} , \quad j=\overline{1,n} \,
. \label{bazov}
\end{equation}
Будем говорить о~полиномах (\ref{bazov}), как о~порожденных
набором $ \{ \lambda_1,\dots,\lambda_n \} $.\newpage


%\begin{theorem}[13] \label{Th0}
{\bf Теорема 2.1} ([13]){\bf .} {\it Имеет место равенство}
\begin{equation}
V^{-1}=\left[ w_{j,k-1} \right]_{j,k=1}^n= \left(
\begin{array}{cccc}
w_{10} & w_{11} & \dots & w_{1,n-1} \\
w_{20} & w_{21} & \dots & w_{2,n-1}  \\
\dots & & & \dots \\
w_{n0} & w_{n1} & \dots & w_{n,n-1}
\end{array}
\right) \ . \label{Wander_inv}
\end{equation}
%\end{theorem}

\so{Доказательство} основывается на~элементарном  свойстве базовых
интерполяционных полиномов:
$$
\widetilde W_j(\lambda_k)=\left\{ \begin{array}{rr} 1  & \mbox{
при } j=k, \\ 0 & \mbox{ при } j\ne k. \end{array} \right.
$$
Умножение матрицы (\ref{Wander_inv}) на~матрицу Вандермонда $V$
слева имеет результатом матрицу, состоящую из~величин $ \widetilde
W_j(\lambda_k) $. \hfill\square

Таким образом, обращение матрицы Вандермонда фактически сводится
к~вычислению коэффициентов базовых интерполяционных полиномов.
Задача заключается теперь в~параллелизации алгоритма вычисления
этих коэффициентов. Сначала вычислим величины

\begin{equation*}
\xi_1=\frac{1}{W^{\prime}(\lambda_1)},\dots,
\xi_n=\frac{1}{W^{\prime}(\lambda_n)}
%\label{tau}
\end{equation*}
и составим из~них столбец

$$
\Xi_0=\left[\xi_1,\dots, \xi_n\right]^{\top}
$$
(здесь и~далее в~статье ${\top} $ означает транспонирование).
Умножим его на~столбец
$$
\Lambda=\left[\lambda_1,\dots, \lambda_n\right]^{\top} \ ,
$$
причем умножение векторов производится поэлементно (так называемое
\emph{адамарово произведение}):
$$
\Xi_1= \Xi_0 \otimes \Lambda= \left[\xi_1 \lambda_1 ,\dots, \xi_n
\lambda_n \right]^{\top} \ .
$$
Продолжив умножение, образуем последовательность
\begin{equation}
\Xi_0, \Xi_1=\Xi_0 \otimes \Lambda, \Xi_2=\Xi_1 \otimes \Lambda,
\dots, \Xi_{n-1}=\Xi_{n-2} \otimes \Lambda, \dots, \Xi_{2n-2} =
\Xi_{2n-3} \otimes \Lambda \ . \label{Seq1}
\end{equation}

\textbf{Лемма.} \textit{Сумма элементов любого из~столбцов $
\Xi_0,\dots,\Xi_{n-2} $ равна $ 0 $. Сумма элементов столбца $
\Xi_{n-1} $ равна $ 1 $}.


\so{Доказательство}. Равенства известны как равенства
Эйлера---Лагран\-жа~[14]
\begin{equation}
\sum_{j=1}^n \frac{\lambda_j^k}{W^{\prime}(\lambda_j)}=\left\{
\begin{array}{cc}
0 & \mbox{\rm при} \ k< n-1, \\
1 & \mbox{\rm при} \ k= n-1.
\end{array}
\right. \label{EUL-Lagr}
\end{equation}\hfill\square
%\begin{theorem} \label{Th1}

{\bf Теорема 2.2.} {\it Вычислим суммы элементов столбцов $ \Xi_n,
\Xi_{n+1},\dots, \Xi_{2n-2} $, т. е. величины
\begin{equation}
\sigma_k = \sum_{j=1}^n
\frac{\lambda_j^{n+k-1}}{W^{\prime}(\lambda_j)} , \quad
k=\overline{1,n-1} \ . \label{sigma}
\end{equation}\newpage
\noindentСтолбцы матрицы $
V^{-1}=\left[V_{[1]}^{-1},V_{[2]}^{-1},\dots, V_{[n]}^{-1} \right]
$ связаны со~столбцами $ (\ref{Seq1}) $ следующими рекурсивными
соотношениями}$:$
\begin{equation}
\left\{
\begin{array}{lcl}
V_{[n]}^{-1}&=&\Xi_0, \\
V_{[n-1]}^{-1}&=&\Xi_1-\sigma_1 V_{[n]}^{-1}, \\
V_{[n-2]}^{-1}&=&\Xi_2-\sigma_1 V_{[n-1]}^{-1} - \sigma_2  V_{[n]}^{-1}, \\
\dots & & \dots \\
V_{[1]}^{-1}&=&\Xi_{n-1}-\sigma_1 V_{[2]}^{-1} - \sigma_2
V_{[3]}^{-1}- \dots - \sigma_{n-1} V_{[n]}^{-1}.
\end{array}
\right. \label{VdMinv2}
\end{equation}


%\end{theorem}

\so{Доказательство}. На~основании (\ref{EUL-Lagr}) имеем
$$ V\cdot V_{[n]}^{-1}=V\cdot \Xi_0=\left[\sum_{j=1}^n\frac{ 1}{W^{\prime}(\lambda_j)},\ \sum_{j=1}^n\frac{ \lambda_j}{W^{\prime}(\lambda_j)},\dots, \sum_{j=1}^n\frac{ \lambda_j^{n-1}}{W^{\prime}(\lambda_j)} \right]^{\top}=
[0,0,\dots,0,1]^{\top} \, .
$$
Далее с~использованием только что полученного равенства получаем
$$ V\cdot V_{[n-1]}^{-1}=V\cdot \Xi_1-\sigma_1 V \cdot V_{[n]}^{-1} =  [0,0,\dots,1,\sigma_1]^{\top} - \sigma_1 [0,0,\dots,0,1]^{\top} = [0,0,\dots,1,0]^{\top} \, . $$
Аналогично, применяя уже два доказанных равенства, доказываем
третье из~(\ref{VdMinv2}):
$$ V\cdot V_{[n-2]}^{-1}=V\cdot \Xi_2-\sigma_1 V \cdot V_{[n-1]}^{-1} - \sigma_2 V \cdot V_{[n]}^{-1} =
$$
$$
=[0,0,\dots,1,\sigma_1,\sigma_2]^{\top} - \sigma_1
[0,0,\dots,1,0]^{\top} - \sigma_2 [0,0,\dots,0,1]^{\top} =
[0,0,\dots,1,0,0]^{\top} \, .
$$
И так далее. \hfill\square



%\begin{example}
{\bf Пример 2.1.} Вычислить
$$
\left(\begin{array}{ccc}
1 & 1 & 1 \\
1 & 2 & 3 \\
1 & 4 & 9
\end{array}
\right)^{-1} \, .
$$
%\end{example}


\textbf{Решение.} Здесь
$$ \lambda_1=1,\ \lambda_2=2,\ \lambda_3=3,\ W^{\prime}(1)=2,\ W^{\prime}(2)=-1,\ W^{\prime}(3)=2 \,  . $$
Вычисляем последовательность столбцов (\ref{Seq1}) и~для
компактности записываем ее в~виде матрицы
$$
\left[ \begin{array}{rrrrr}
1/2 & 1/2 & 1/2 & 1/2 & 1/2 \\
-1  &  -2 & -4 & -8 & -16 \\
1/2 & 3/2 & 9/2 & 27/2 & 81/2
\end{array}
\right] \ .
$$
Суммируем элементы двух последних столбцов:
$$ \sigma_1=6,~ \ \sigma_2=25 \, . $$
Используем формулы (\ref{VdMinv2}):
\begin{eqnarray*}
V_{[3]}^{-1}&=& \left[ \begin{array}{r}
1/2 \\
-1   \\
1/2
\end{array}
\right], \ \\
V_{[2]}^{-1}&=& \left[ \begin{array}{r}
1/2 \\
-2   \\
3/2
\end{array}
\right]- 6 \left[ \begin{array}{r}
1/2 \\
-1   \\
1/2
\end{array}
\right]= \left[ \begin{array}{r}
-5/2 \\
4   \\
-3/2
\end{array}
\right], \\
V_{[1]}^{-1}&=& \left[ \begin{array}{rrrrr}
1/2  \\
-4  \\
9/2
\end{array}
\right] - 6\, \left[ \begin{array}{r}
-5/2 \\
4   \\
-3/2
\end{array}
\right]-25\, \left[ \begin{array}{r}
1/2 \\
-1   \\
1/2
\end{array}
\right]= \left[ \begin{array}{r}
3\\
-3   \\
1
\end{array}
\right] \ .
\end{eqnarray*}


\textbf{\so{Замечание} 1.} Для вещественных матриц Вандермонда
формулы (\ref{VdMinv2}) можно рассматривать как результат процесса
ортогонализации Грама---Шмидта [15], примененного к~системе
столбцов $ \{\Xi_0,\Xi_1,\dots,\Xi_{n-1}\} \subset \mathbb R^n $
при скалярном произведении в~$ \mathbb R^n $, задаваемом формулой
$\left<X,Y\right>=X^{\top} (V^{\top} V) Y $.


\textbf{\so{Замечание} 2.} Можно доказать, что величина
(\ref{sigma}) может быть вычислена как сумма всевозможных мономов
степени $ k $ от элементов $ \lambda_1,\dots,\lambda_n $:
$$
\sigma_k=\sum_{j_1\ge 0, j_2\ge 0, \dots j_n\ge 0 \atop
j_1+j_2+\dots+j_n=k} \lambda_1^{j_1} \lambda_2^{j_2}\times \dots
\times \lambda_n^{j_n} \, .
$$


%\begin{theorem} \label{Th2}
{\bf Теорема 2.3.} {\it Пусть задан набор неотрицательных разных
целых чисел $ \{k_0,k_1,\dots,k_{m-1} \} $ и~элемент $ \lambda $
поля такой, что элементы $
\lambda^{k_0},\lambda^{k_1},\dots,\lambda^{k_{m-1}} $ все
различны. Пусть
$$ g(x)=\prod_{j=0}^{m-1} (x-\lambda^j) \, .  $$
 Для произвольного полинома $ f(x) $ над полем существует единственная пара полиномов $ \mathcal Q(x) $ и~\begin{equation}
 \mathcal R(x)=C_0x^{k_0}+C_1x^{k_1}+\dots + C_{m-1}x^{k_{m-1}}
 \label{polyR}
\end{equation}
такая, что}
\begin{equation}
 f(x) \equiv \mathcal Q(x) g(x) + \mathcal R(x) \, .
 \label{gen_divis}
\end{equation}
%\end{theorem}

\so{Доказательство}. Если подставить в~тождество (\ref{gen_divis})
значения $ 1,\lambda $, $ \lambda^2,\dots,\lambda^{m-1} $, то
получим систему линейных уравнений относительно коэффициентов $
C_0,C_1,\dots,C_{m-1} $. Матричный вид этой системы
\begin{equation}\label{matrix1}
 V_{m,m}(\lambda^{k_0}, \lambda^{k_1},\dots,\lambda^{k_{m-1}}) \mathbf C =\left[f(1),f(\lambda),\dots, f(\lambda^{m-1}) \right]^{\top} \
\end{equation}
при $\mathbf C =\left[ C_0,C_1,\dots,C_{m-1} \right]^{\top}$.

По условию теоремы матрица системы (\ref{matrix1}) невырождена.
Следовательно, система имеет единственное решение, которое
однозначно определяет полином  $ \mathcal R(x) $. Тогда разность $
f(x)- \mathcal R(x) $ нацело делится на~полином $ g(x) $,
и~полином $ \mathcal Q(x) $ определяется как  частное этого
деления. \hfill\square

В случае $ k_j=j-1$,\ $j=\overline{1,r} $,  теорема 2.3 фактически
предоставляет способ осуществления деления $ f(x) $ на~$ g(x) $.
Нас, однако, будут интересовать упрощения вычислений <<обобщенного
остатка>> (\ref{polyR}), например, для случая полинома $ f(x) $
вида
$$ f(x)=A_1x_1^{n_1}+\dots+A_rx^{n_r} \quad \mbox{ при } \   \{n_1,\dots,n_r \} \subset \mathbb Z,~ 0\le n_1< \dots< n_r \, .  $$
С этой целью решение системы (\ref{matrix1}) запишем так:
$$
\left[C_0,C_1,\dots, C_{m-1} \right]^{\top}
=\left[V_{m,m}(\lambda^{k_0},
\lambda^{k_1},\dots,\lambda^{k_{m-1}})\right]^{-1}
\left[f(1),f(\lambda),\dots, f(\lambda^{m-1}) \right]^{\top} =
$$
\begin{equation}
=\left[V_{m,m}(\lambda^{k_0},
\lambda^{k_1},\dots,\lambda^{k_{m-1}})\right]^{-1}
V_{m,r}(\lambda^{n_1},\dots,\lambda^{n_r}) \left[A_1,\dots, A_r
\right]^{\top} \, . \label{gen_remainder}
\end{equation}
На основании теоремы 2.1 приходим к~следующему результату.
%\begin{theorem} \label{Th3}

{\bf Теорема 2.4.} {\it Коэффициенты полинома $(\ref{polyR})$
находятся из~равенства
\begin{equation*}
\left(\begin{array}{l} C_0 \\ C_1 \\ \vdots \\ C_{m-1}
\end{array}
\right)= \left(\begin{array}{llll}
\widetilde W_1(\lambda^{n_1}) & \widetilde W_1(\lambda^{n_2}) & \dots & \widetilde W_1(\lambda^{n_r}) \\
\widetilde W_2(\lambda^{n_1}) & \widetilde W_2(\lambda^{n_2}) & \dots & \widetilde W_2(\lambda^{n_r}) \\
\vdots & \vdots & & \vdots \\
\widetilde W_m(\lambda^{n_1}) & \widetilde W_m(\lambda^{n_2}) &
\dots & \widetilde W_m(\lambda^{n_r})
\end{array}
\right) \left(\begin{array}{l} A_1 \\ \vdots \\ A_r
\end{array}
\right) \ . \label{CAR}
\end{equation*}
Здесь $ \widetilde W_1(x),\dots, \widetilde W_m(x) $ --- базовые
интерполяционные полиномы Лагранжа, порожденные набором $
\{\lambda^{k_0},\lambda^{k_1},\dots,\lambda^{k_{m-1}} \} $. }
%\end{theorem}

\textbf{\so{Замечание} 3.} Предположение о~неотрицательности
показателей $ n_j, j=\overline{1,r} $, и~$ k_{s},s
=\overline{0,m-1} $, в~формулировках теорем 2.3 и~2.4 не является
существенным: эти результаты позволяют определить операцию деления
и~для обобщенных полиномов (Лорана), т.~е. линейных комбинаций
мономов с~произвольными целыми показателями.


{\bf 3. Систематическое кодирование кодов
Рида---Соломона.} %\label{RS_stand}
РС-коды  представляют собой циклические коды, позволяющие
исправлять ошибки в~блоках данных. От исходного набора (вектора)
информационных кодовых блоков $(D_0, D_1, \ldots, D_{n-1})$
по~специальным формулам рассчитываются \emph{синдромы}, т. е.
служебная информация в~виде вектора блоков $ (C_0, C_1, \ldots,
C_{m-1})$. Формулы расчета синдромов подбираются таким образом,
чтобы гарантированно исправить определенное количество ошибок,
которые могут возникнуть в~процессе хранения или передачи.

Различают два способа расчета синдромов РС-кодов: cистематическое
кодирование и~несистематическое кодирование. При систематическом
кодировании сохраняемая  или передаваемая информация
представляется в~виде конкатенации инфор\-мационных блоков
и~блоков синдромов $(D_0, D_1, \ldots, D_{n-1}, C_0, C_1, \ldots,
C_{m-1})$ в единый кодовый вектор. В~дальнейшем будем
рассматривать только такое кодирование как наиболее востребованное
на~практике. При его применении в~случае отсутствия
по\-вреж\-де\-ний данных не~требуется осуществлять декодирование
и, следовательно, тратится меньше вычислительных ресурсов
на~извлечение информационных блоков.

Расчет синдромов осуществляется с~использованием арифметики
конечных полей. Каждый кодовый блок $ D_j $, представленный в~виде
$ w $-битного вектора, считается элементом некоторого поля Галуа $
GF(2^w)$. Мы не~останавливаемся здесь подробно на~описании
арифметики полей Галуа [7--9]. Напомним только, что множество
ненулевых элементов поля $ GF(2^w)$ замкнуто относительно
умножения, и~в~нем существует \emph{примитивный элемент} $ a $,
т.~е. такой, что все его степени $ a^0,a^1,\dots,a^{2^w-2} $
представляют все эти элементы поля.

Пусть код должен быть устойчив к~отказу $\ell $ блоков
и~дополнительно к~появлению самое большее $t$ скрытых повреждений.
Тогда избыточность кода должна состоять, как минимум,
из~$m=\ell+2t$ синдромов. Для их расчета выбирается порождающий
полином кода, например в~виде
$$g(x) = \prod_{j=0}^{m-1}(x+a^{j}) \, .$$
По информационным кодовым блокам $D_0,D_1,\ldots,D_{n-1}$
составляется полином
$$
G(x) = D_0x^{n-1}+D_1x^{n-2}+\cdots+D_{n-2}x+D_{n-1} \, .
$$
Для расчета синдромов разделим полином $\widetilde{G}(x)\equiv
G(x) x^m$  на~$g(x)$ и~обозначим через $ \mathcal Q(x) $ частное,
а через  $ \mathcal R(x)$ --- остаток от деления:
$$
\widetilde{G}(x)\equiv \mathcal Q(x)g(x)+ \mathcal R(x) ,~ \ \deg
\mathcal R < m \, .
$$
В качестве синдромов берутся коэффициенты остатка
$$
\mathcal R(x) = C_0x^{m-1} + C_1x^{m-2}+\cdots+C_{m-1} \, ,
$$
а в~качестве кодового вектора выбирается вектор
\begin{equation}
(Y_0,\ldots,Y_{N-1})= (D_0,D_1,\ldots,D_{n-1},C_0,\dots,C_{m-1}) ,
\quad N=n+m, \label{sequence0}
\end{equation}
коэффициентов полинома $\overline{G}(x)=\widetilde{G}(x)+\mathcal
R(x)$. Для этого полинома выполняются условия
\begin{equation*}\label{rs0}
\overline{G}(1)=0, \quad \overline{G}(a)=0,\ldots, \ \overline{G}
(a^{m-1})=0 \, .
\end{equation*}
Обратно, если  необходимо проверить некоторый вектор $
(Y_0,\ldots,Y_{N-1}) $ на~наличие в~нем ошибок, то составляем
полином $\overline{G}(x)=Y_0x^{N-1}+\dots+Y_{N-1}$ и~вычисляем его
значения на~степенях примитивного элемента поля:
\begin{equation}
S_j= \overline{G}(a^j)=\sum_{i=0}^{N-1} Y_i a^{(N-1-i)j} , \quad
j=\overline{0,m-1} \, . \label{check_sum0}
\end{equation}
Если хотя бы одно из~этих значений \emph{контрольных сумм}
ненулевое, то это свидетельствует о~наличии в~векторе ошибок.
Значения $S_0,\dots, S_{m-1}$ используются тогда для
восстановления данных, как будет показано в~п.~4.

{\bf 4. Кодирование и~исправление ошибок: матричный подход.} %\label{Srec_matr}
Нахождение синдромов $ C_0,\dots,C_{m-1} $ способом, описанным в~п.~3, требует существенных машинных ресурсов, поскольку использует трудоемкую операцию деления полиномов над конечными полями.
В альтернативу этому предлагается применить для кодирования
изложенный в~п.~2 подход к~вычислению остатков, основанный
на~матричном формализме.  По~теореме 2.4 синдромы связаны
с~информационными блоками соотношением
\begin{equation}
\label{coding_matrix} \left(
\begin{array}{l}
C_0 \\ C_1 \\ \vdots \\ C_{m-1}
\end{array}
\right) =
\begin{pmatrix}
    \widetilde{W}_1(a^{N-1})& \widetilde{W}_1(a^{N-2})& \cdots& \widetilde{W}_1(a^{m}) \\
    \widetilde{W}_2(a^{N-1})& \widetilde{W}_2(a^{N-2})& \cdots& \widetilde{W}_2(a^{m}) \\
    \vdots& \vdots& & \vdots& \\
    \widetilde{W}_m(a^{N-1})& \widetilde{W}_m(a^{N-2})& \cdots& \widetilde{W}_m(a^{m})
\end{pmatrix}
\left(
\begin{array}{l}
D_0 \\ D_1 \\ \vdots \\ D_{n-1}
\end{array}
\right) \ ,
\end{equation}
представляющим процедуру кодирования в~матричном виде. Здесь $
\widetilde{W}_1 (x),\dots,  \widetilde{W}_m (x) $ означают базовые
интерполяционные полиномы Лагранжа, порожденные элементами поля $
\{a^{m-1}, a^{m-2},\dots,1 \} $. Матрицу из~формулы
(\ref{coding_matrix})
$$
\mathbf K=[\widetilde{W}_i(a^{N-j-1})],\quad i=\overline{1,m},
\quad j=\overline{0,n-1} \ ,
$$
назовем \emph{матрицей кодирования}. При фиксированных числах $m$
и $n$ ее расчет производится однократно и~позволяет осуществлять
процедуру кодирования для произвольного вектора из~$ n $
информационных блоков --- и~в~этом заключается его преимущество
перед традиционным подходом, основанном на~полиномиальном
формализме. Заметим также, что  каждый синдром рассчитывается
за~$O(n)$ операций и~вычисление всего набора синдромов может
производиться параллельно, т.~е. независимо друг от друга.


Использовать свойства матрицы Вандермонда можно и~для
восстановления утраченных данных. Предположим, что для блоков
данных $D_0,D_1,\ldots,D_{n-1}$ были рассчитаны $m$ синдромов
$C_0,C_1,\ldots,C_{m-1}$, например, по~формуле
(\ref{coding_matrix}). Пусть в~кодовой последовательности
(\ref{sequence0}) произошло $\ell \le m$ отказов, т.~е.
повреждений блоков с~известными номерами $k_1,\ldots,k_{\ell}$.
Обозначим
$$ \mathbf{Y}_{_{\mathfrak f}} = \left[Y_{k_1},\dots,  Y_{k_{\ell}} \right]^{\top} $$
столбец отказавших блоков, а~$$\mathbf Y_{_{\mathfrak
s}}=[Y_{r_1},\dots, Y_{r_{N-\ell}}]^{\top},\ $$
$$ \{r_1,\dots,r_{N-\ell}\}=\{0,\ldots,N-1\}\setminus\{k_1,\ldots,k_{\ell}\},~ \ r_1< r_2 < \dots < r_{N-\ell}, $$
--- столбец неповрежденных блоков.

Тогда алгоритм восстановления отказавших блоков заключается
в~следующем. Сначала пересчитываются значения первых $ \ell $
контрольных сумм из~(\ref{check_sum0}) с~пропуском при расчете
отказавших блоков:
\begin{equation} \label{check_sum1}
\widehat{S}_j= \sum_{i= \overline{0,N-1} \atop i \not\in
\{k_1,\dots,k_{\ell} \} } Y_i a^{(N-1-i)j} , \quad
j=\overline{0,\ell-1} \, .
\end{equation}
В матричном виде это можно записать так:
\begin{equation}\label{step1}
\widehat{\mathbf S}
=V_{\ell,N-\ell}(a^{N-r_1-1},a^{N-r_2-1},\dots,a^{N-r_{N-\ell}-1})
\mathbf Y_{_{\mathfrak s}},
\end{equation}
где $\widehat{\mathbf
S}=\left[\widehat{S}_0,\widehat{S}_1,\dots,\widehat{S}_{\ell-1}
\right]^{\top} $.

Для восстановления отказавших блоков составим систему линейных
уравнений суммированием соответствующих уравнений
(\ref{check_sum0}) и~(\ref{check_sum1}):
$$
\sum_{i=1}^{\ell} Y_{k_i} a^{(N-1-k_i)j}= \widehat{S}_j,\quad
j=\overline{0,\ell-1} \, .
$$
Вектор $ \mathbf{Y}_{_{\mathfrak f}} $ выражается отсюда
посредством обращения матрицы Вандермонда:
\begin{equation}\label{step2}
\mathbf{Y}_{_{\mathfrak f}}=[V_{\ell,\ell}(a^{N-k_1-1},
a^{N-k_2-1},\ldots, a^{N-k_{\ell}-1})]^{-1} \widehat{\mathbf S} \,
.
\end{equation}
Подставив (\ref{step1}) в~(\ref{step2}), получим выражение
отказавших блоков через неповрежденные:
\begin{equation}
\mathbf{Y}_{_{\mathfrak f}}= [V_{\ell,\ell}(a^{N-k_1-1},\ldots,
a^{N-k_{\ell}-1})]^{-1}
V_{\ell,N-\ell}(a^{N-r_1-1},a^{N-r_2-1},\dots,a^{N-r_{N-\ell}-1})
\mathbf Y_{_{\mathfrak s}} \, . \label{step3}
\end{equation}
В соответствии с~формулой (\ref{gen_remainder}) можно утверждать,
что отказавшие блоки состав\-ляют набор коэффициентов обобщенного
остатка
$$
c_1 x^{N-1-k_1}+ c_2 x^{N-1-k_2}+ \dots + c_{\ell}
x^{N-1-k_{\ell}}
$$
от деления полинома
$$Y_{r_1}x^{N-1-r_1}+ Y_{r_2}x^{N-1-r_2}+\dots+Y_{r_{N-\ell}}x^{N-1-r_{N-\ell}} $$
на полином

$$
\prod_{i=0}^{\ell-1} (x+a^i) \, .
$$

\vspace{3mm} \noindentНа основании теоремы 2.4 можно записать
произведение матриц, стоящих в~правой части (\ref{step3}) в~виде

$$
\mathbf R_{\ell,N-\ell}= \left(
\begin{array}{llll}
    \widetilde{W_1}(a^{N-r_1-1})& \widetilde{W_1}(a^{N-r_2-1})& \dots& \widetilde{W_1}(a^{N-r_{N-\ell}-1}) \\
    \widetilde{W_2}(a^{N-r_1-1})& \widetilde{W_2}(a^{N-r_2-1})& \dots& \widetilde{W_2}(a^{N-r_{N-\ell}-1}) \\
    \vdots& \vdots&  &  \vdots \\
   \widetilde{W_{\ell}}(a^{N-r_1-1})& \widetilde{W_{\ell}}(a^{N-r_2-1})& \dots& \widetilde{W_{\ell}}(a^{N-r_{N-\ell}-1})
\end{array}
\right)
$$

\vspace{3mm} \noindentили компактно ---

$$
\mathbf R=[\widetilde{W_i}(a^{N-j-1})], \quad i=\overline{1,\ell},
\quad j\in \{0,\dots,N-1\}\setminus \{k_1,\dots,k_{\ell}\} \, ;
$$

\vspace{3mm} \noindentздесь $ \widetilde{W_1}(x),\dots,
\widetilde{W_{\ell}}(x) $ --- базовые интерполяционные полиномы
Лагранжа, порожденные набором $
\{a^{N-k_1-1},\dots,a^{N-k_{\ell}-1} \} $.

Окончательно значения отказавших блоков могут быть восстановлены
по формуле

\begin{equation}\label{recovery_matrix}
\mathbf{Y}_{_{\mathfrak f}}=\mathbf R \cdot \mathbf Y_{_{\mathfrak
s}} \, .
\end{equation}

\vspace{3mm} \noindentМатрицу $ \mathbf R $ естественно назвать
\emph{матрицей восстановления} (декодирования). Данный способ
восстановления имеет то достоинство, что восстановление отказавших
блоков происходит напрямую из~неповрежденных и~не~требует
дополнительной памяти для хранения промежуточных вычислений. Также
следует отметить, что при восстановлении данных, например в~СХД,
расчет матрицы восстановления  $ \mathbf R $ выполняется
однократно для всех векторов, в~которых необходимо восстановить
данные. В~связи с~этим после расчета матрицы для ее элементов
могут быть вычислены вспомогательные значения, необходимые для
быстрого умножения, описанного в~[10], что приведет к~увеличению
скорости восстановления.

Описанные способы кодирования и~декодирования корректно
восстанавливают данные при выполнении условия $m+n<2^w$, т.~е.
общее число блоков не~превышает порядка используемого поля. При
необходимости исправления большего количества ошибок требуется
переход к~полям б\'ольших порядков.



РС-коды замечательны еще и~тем, что позволяют не~только исправлять
отказы, но~также обнаруживать наличие и~исправлять стирания, или
скрытые повреждения  (Silent Data Corruption, SDC), т.~е. такие
повреждения исходных данных, которые не~отслеживаются аппаратными
средствами.

Приведем здесь лишь краткое описание алгоритма обнаружения
и~исправления скрытых повреждений, поскольку он подробно
рассмотрен в литературе [7, 8]. Пусть в~последовательности блоков
(\ref{sequence0}) имеется $\ell $ отказов в~блоках с~номерами
$k_1,\ldots,k_{\ell}$  и~$t$ скрытых повреждений в~блоках
с~номерами $j_1,j_2,\ldots,j_t$, которые априори неизвестны (как
неизвестно и~само их количество). В~предположении,
что\linebreak\newpage\noindent выполняется условие $\ell+2t\leq
m$, все скрытые повреждения могут быть обнаружены и~исправлены.
Чтобы обнаружить присутствие и~найти расположение скрытых
повреждений в~таком случае необходимо:

1) пересчитать значения контрольных сумм c пропуском отказавших
блоков по~формуле (\ref{step1});

2) (в случае $\ell=0$  этот шаг пропускается) построить
вспомогательный полином
$$
z(x)=\prod_{i=1}^{\ell}{(x+a^{N-k_i-1})}=z_0+z_1x+\cdots+z_{\ell}x^{\ell}
\,  ;
$$

3) посчитать величины
$$
U_i= \left\{
\begin{array}{ll}
\displaystyle \sum_{j=0}^{\ell}z_{j} \widehat{S}_{i+j}, & \mbox{\rm если} \ \ell>0, \\
\widehat{S}_i, & \mbox{\rm если} \ \ell=0,
\end{array}  \quad i=\overline{0,m-\ell-1} \, ;
\right.
$$

4) если хотя бы одно из~условий $U_0=0,\dots, U_{m-\ell-1}=0 $
не~выполнено, то делается вывод о~наличии скрытых повреждений;

5) построить полином локаторов ошибок --- например, по~алгоритму
Берлекам\-па---Месси. На~вход алгоритма подается
последовательность $U_{m-\ell-1},U_{m-\ell-2},\ldots,U_0$.
На~выходе получается полином степени $ t $.  Если количество
скрытых повреждений в~точности равно $ t $, то корнями этого
полинома являются $a^{N-j_i-1},~ i=\overline{1,t}$. С~определением
этих корней устанавливаются места скрытых повреждений.

Когда все они определены, задача исправления поврежденных данных
ока\-зы\-вает\-ся сведенной к~случаю наличия в~последовательности
(\ref{sequence0}) исключительно только отказов. Последние могут
быть исправлены, например, по~формуле (\ref{recovery_matrix}).


{\bf 5. Результаты вычислительных экспериментов.} Для практической
реа\-ли\-за\-ции описанных алгоритмов кодирования и~декодирования
был выбран язык С, поскольку он обеспечивает доступ к~векторным
инструкциям процессора, и~в~то же время компиляторы языка
С~реализуют различные алгоритмы оптимизации исполняемого кода.
Было произведено сравнение описанного в~п.~4 алгоритма с~наиболее
популярными библиотеками помехоустойчивого кодирования ISA-L [16],
Jerasure [17]. Производилось сравнение только скорости работы
алгоритма кодирования или декодирования, без учета считывания
данных с~дисков, на~системе со~следующей конфигурацией:
\begin{itemize}\begin{itemize}
\item
OC: Debian 8;
\item
CPU: Intel Core i7-2600 3.40GHz;
\item
RAM: 8GB;
\item
компилятор gcc 4.8.
\end{itemize}\end{itemize}


На рисунке,~$I$--$III$ представлены результаты сравнений
алгоритмов с~большим количеством контрольных сумм ($n$ ---
количество информационных блоков, $m$ --- количество контрольных
сумм, $N=n+m$ --- общее количество блоков). Матричная версия
алгоритма кодирования из~п.~4 обозначена как ``rdx''.  Можно
увидеть, что эта версия показывает примерно такие же показатели
скорости кодирования, как и~ISA-L, но~более высокие значения
скорости исправления ошибок. Следует заметить, что в~отличие от
упомянутых библиотек разработанная авторами  программная
реализация алгоритма позволяет исправлять не~только отказы, но~и
скрытые повреждения.

%\begin{figure}[h!]
%\center{\includegraphics[scale=0.52]{n16.jpg}} \caption{ Сравнение
%скорости кодирования и~декодирования при $n=16$.} \label{fig:n16}
%\vfill \center{\includegraphics[scale=0.52]{n32.jpg}} \caption{
%Сравнение скорости кодирования и~декодирования при $n=32$.}
%\label{fig:n32} \vfill
%\center{\includegraphics[scale=0.52]{n96.jpg}} \caption{ Сравнение
%скорости кодирования и~декодирования при $n=96$.} \label{fig:n96}
%\end{figure}

\newpage

\begin{figure}[h!]
\centering
\includegraphics[scale=1]{01/fig1}\\
\vskip 3mm \small{Сравнение скорости кодирования (слева)
и~декодирования (справа) } \\%\label{fig:n96}
 \vskip 1mm \small{при $n=$ 16 ($I$), 32 ($II$) и 96
($III$)$ }
\end{figure}

%\newpage

{\bf 6. Заключение.} В~настоящей работе решается проблема
повышения эффективности применения кодов Рида---Соломона для
исправления поврежденных данных. Предложенный алгоритм, основанный
на~матричных операциях с~использованием матрицы Вандермонда,
программно реализован на~языке C. В~сравнении  с~существую\-щими
специализированными пакетами эта программная реализация показывает
высокие значения скорости кодирования и~декодирования, притом что
дополнительно обеспечивает высокую степень отказоустойчивости
за~счет возможности\linebreak исправления как отдельно отказов или
скрытых повреждений, так их произвольных комбинаций.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{01/lit-ra}

%%%%%N DOI в~ссылке!!!!!!!!!!

\input{01/ref-s}

%%%%%N DOI в~ссылке!!!!!!!!!!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\footnotesize



\vskip 3mm

%\thispagestyle{empty}



\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
\fancyfoot[LO]{\footnotesize{\it{Вестник~СПбГУ.~Сер.~10.~Прикладная~математика.~Информатика...~\issueyear.~Вып.~\issuenum}}
\hfill}%
\fancyfoot[RE]{\hfill\footnotesize{\it{Вестник~СПбГУ.~Сер.~10.~Прикладная~математика.~Информатика...~\issueyear.~Вып.~\issuenum}}}%
%\lhead{} %верхний колонтитул слева
%%\rhead{} % верхний колонтитул справа
% для оформления нижнего колонтитула
\cfoot{} %
%\lfoot{} %
%\rfoot{\thepage} %


\noindent Статья рекомендована к~печати проф. Л. А. Петросяном.

\vskip 1mm

\noindent Статья поступила в~редакцию 15 июля 2016~г.

\vskip 1mm

\noindent Статья принята к~печати 29 сентября 2016~г.


}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\vskip 5mm

%{\footnotesize

%\noindent К\,о\,н\,т\,а\,к\,т\,н\,а\,я\,
%и\,н\,ф\,о\,р\,м\,а\,ц\,и\,я \nopagebreak \vskip 3mm

%{\it Балонин Николай Алексеевич}~-- доктор технических наук,
%профессор; e-mail: korbendfs@mail.ru

%{\it Сергеев Михаил Борисович}~-- доктор технических наук,
%профессор,  директор; e-mail: mbse@mail.ru

%\vskip 2mm

%\emph{Balonin Nikolaj Alekseevich}~-- doctor of technical
%sciences, professor; e-mail: korbendfs@mail.ru


%\emph{Sergeev Mikhail Borisovich}~-- doctor of technical sciences,
%director; e-mail: mbse@mail.ru


%}


%\thispagestyle{empty}
