


\noindent{\small УДК 519.8  \hfill {\footnotesize Вестник~СПбГУ.~Прикладная~математика.~Информатика...~\issueyear.~Т.~17.~Вып.~\issuenum}\\
MSC 90B35

}

\vskip3mm

\noindent{\bf Алгоритм составления расписания для одного процессора\\ с~гарантированной оценкой точности 3/2%$^{*}$%
 }

\vskip3mm

\noindent{\it Н.~С.~Григорьева%$\,^2$%
%, И.~О. Фамилия%$\,^2$%
}

\efootnote{
%%
%\vspace{-3mm}\parindent=7mm
%%
%\vskip 0.1mm $^{*}$ Работа выполнена при%
%финансовой поддержке Российского%
%фонда фундаментальных исследований%
%(грант № 19-01-00146-a).\par%
%%
%%\vskip 2.0mm
%%
\indent{\copyright} Санкт-Петербургский государственный
университет, \issueyear%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
\fancyfoot[LO]{{\footnotesize\rm{\doivyp/spbu10.\issueyear.\issuenum02 } }\hfill\thepage}%
\fancyfoot[RE]{\thepage\hfill{\footnotesize\rm{\doivyp/spbu10.\issueyear.\issuenum02}}}%
% для оформления нижнего колонтитула
\cfoot{} %

\vskip3mm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\footnotesize




\noindent%
%$^2$~%
Санкт-Петербургский государственный университет, Российская
Федерация,

\noindent%
%\hskip2.45mm%
199034, Санкт-Петербург, Университетская~наб., 7--9

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vskip3mm

{\small \noindent \textbf{Для цитирования:}
\textit{Григорьева Н.~С.}
Алгоритм составления расписания для одного процессора с~гарантированной оценкой точности 3/2~//
Вестник Санкт-Пе\-тер\-бург\-ского университета. Прикладная
математика. Информатика. Процессы управления. \issueyear. Т.~17.
Вып.~\issuenum.
С.~\pageref{p2}--\pageref{p2e}. %\\
\doivyp/\enskip%
\!\!\!spbu10.\issueyear.\issuenum02

\vskip3mm

{\leftskip=7mm\noindentРассматривается задача составления расписания для одного процессора   $1|r_i,q_i|C_{\max}$,
в которой для каждого задания известны времена поступления,  времена  выполнения и~времена доставки. Предлагается новый приближенный алгоритм решения задачи $1|r_i,q_i|C_{\max}$ с~гарантированной оценкой точности 3/2 и~вычислительной сложностью $O(n\log n).$ Приводятся пример,  показывающий, что данная оценка асимптотически
достигается, и~результаты вычислительного эксперимента, свидетельствующие о~быстродействии и~практической точности алгоритма.\\[1mm]
\textit{Ключевые слова}: задача составления расписания, времена поступления,
времена доставки, приближенный алгоритм, гарантированная оценка точности.

}

}

\vskip 4mm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   {\bf 1. Введение.}
В работе рассматривается задача составления расписания, в~которой
   $n$ заданий  выполняется  на одном процессоре.
        Пусть  $U$   --- множество заданий и~для каждого задания $i \in U$
        заданы:
         время поступления на исполнение ---
            $r(i) $,
             время выполнения  --- $t(i)$
             и~время доставки  ---
           $q(i)$.



Считаем, что доставка начинается сразу после завершения выполнения задания процессором
и может осуществляться одновременно с~его работой.
 Прерывания выполнения заданий не допускаются, и~в~каждый момент времени процессор
может исполнять не более одного задания.
   Требуется  построить расписание, т. е.
    найти для каждого задания $i$ время начала  его выполнения $\tau(i)$, при условии, что
$ r(i) \leq \tau(i).$
    Характеристика качества расписания --- время доставки последней работы
        $C_{\max}=\max\{\tau(i)+t(i)+q(i) |   i \in U\}$.
 Требуется построить расписание, минимизирующее   $C_{\max}$.

Следуя  схеме, предложенной Р. Грехемом и~др. [1],   задача обозначается как   $1|r_i, q_i|C_{\max}$.
 В~[2] показано, что задача $NP$-трудная в~сильном смысле, но существуют точные полиномиальные
алгоритмы для ряда специальных случаев.   В~[3]  рассматривалась
  эквивалентная постановка задачи, в~которой вместо времени доставки
для каждой работы известен директивный срок  $D(i)=K - q(i)$, где $ K $ --- константа,
и целевой функцией яв\-ляет\-ся максимальное временное смещение $L_{\max}=\max\{\tau(i)+t(i) - D(i) |  i \in U\}$.
 Эта постановка задачи обозначается как $1|r_i|L_{\max}$.
Преимущество модели с~временами доставки заключается в~том, что  целевая функция всегда положительна, тогда как максимальное
временное смещение может быть отрицательным или равным нулю. Если поменять местами времена доставки и~времена поступления заданий,
  получим инверсную задачу со свойством,
что     решение прямой задачи  $S=(i_1,i_2,...,i_n)$       оптимально  тогда и~только тогда,  когда перестановка
  $S_{inv}=(i_n,i_{n-1},..., i_1)$  есть оптимальное решение
инверсной  задачи.


В большинстве исследований  задач составления расписаний рассматриваются незадерживающие расписания,
   определенные К. Бейкером [4] как допустимые расписания,
в которых процессор не должен простаивать, если есть задания, которые процессор может выполнять. Одним из популярных инструментов
построения расписаний служат
списочные алгоритмы, которые строят незадерживающие расписания. В~списочном алгоритме на каждом шаге
 из множества готовых заданий выбирается задание с~максимальным приоритетом.
 Но оптимальное расписание может не принадлежать
классу незадерживающих расписаний.


 Расписания с~невынужденными простоями  (inserted idle time --- IIT) были определены
   в~[5] как допустимые расписания, в~которых
процессор может простаивать при наличии готовых к~выполнению заданий.
 В~[5] авторы приводят обзор литературы моделей составления расписаний,
в которых актуально использование невынужденных простоев.


 Приближенные расписания с~невынужденными  простоями для  параллельных процессоров  рассматривались:
для задачи  $P|{\mathrm{prec}}|C_{\max}$, в~которой на множестве заданий известно отношение
частичного порядка [6], и~для задачи  $P|r_j,q_j|C_{\max}$  с~заданными
  временами  поступления и~доставки
 [7, 8].
Основной идеей  алгоритмов  для решения этих задач был выбор на каждом шаге самого приоритетного задания,
  до  начала выполнения которого процессор мог простаивать.

В  [9] для задачи с~одним процессором был предложен  допускающий невынужденные  простои алгоритм
  с~гарантированной оценкой точности, равной 2.
В настоящей работе  предлагается новый приближенный алгоритм составления расписания для задачи с~одним процессором.







Известны несколько  алгоритмов с~гарантированной оценкой точности для
решения задачи $1|r_i,q_i|C_{\max}$.

 Первым алгоритмом построения приближенного расписания  была
 эвристика  Шраге --- расширенное правило Джексона, которое  формулируется следующим образом:
 каждый раз, когда процессор освобождается,
 на него назначается готовая работа с~максимальным временем доставки [10].
     Вычислительная сложность алгоритма $O(n\log n).$ В~работе Х. Кизе и~др. [11] показано, что алгоритм имеет гарантированную оценку точности,
равную 2.

 K. Поттс  [12]   предложил алгоритм, в~котором  $n$ раз запускается
 процедура, реализующая  правило Джексона.
  Перед каждым новым запуском
к ограничениям задачи добавляется новое ограничение на порядок выполнения заданий. Из $n$
 построенных расписаний выбирается
лучшее.
 Вычислительная сложность алгоритма Поттса $O(n^2\log n).$ Гарантированная оценка точности равна 3/2.


        Л. Холл и~Д. Шмойс  [13]  рассматривали наряду с~прямой задачей
инверсную задачу, в~которой времена поступления заданий и~времена доставки меняются местами.
Авторы разработали  метод построения расписания, в~ котором  алгоритм Поттса применяется для прямой и~инверсной задач.
   Отдельно рассматривается случай,  в~котором есть два длительных задания.
 В~общей сложности
 алгоритм строит  $4n$   расписаний и~выбирает из них лучшее.
  Вычислительная сложность алгоритма  $O(n^2\log n).$ Гарантированная оценка точности равна 4/3.

         Е. Новицкий и~К. Смутницкий [14]
 предложили алгоритм с~гарантированной оценкой точности 3/2, который создает только  две перестановки.
 Первый раз применяется правило Джексона, далее определяется
  интерференционная  работа, и~все множество заданий разбивается  на два множества:
 задания, которые должны выполняться до интерференционной  работы, и~задания, которые должны
 выполняться после нее. Задания из первого множества устанавливаются в~порядке поступления, из второго~--- по невозрастанию времени доставки.
Выбирается лучшее расписание из двух построенных.
 Вычислительная сложность  $O(n\log n).$ Гарантированная оценка точности равна  3/2.

Все упомянутые алгоритмы используют списочный жадный алгоритм Шраге как базовую эвристику.

 Для  задачи $1|r_i,q_i|C_{\max}$ известны также полиномиально-временные ап\-прокси\-ма\-цион\-ные схемы  (PTAS).
  Две такие схемы предложили Л.~Холл и~Д.~Шмойс [13, 15], а~М.~Мастролилли  [16] улучшил их результаты, предложив  PTAS  с~линейной сложностью.



 Е. Новицкий и~К. Смутницкий [14] поставили в~своей работе  вопрос: какое минимальное количество перестановок
надо построить, чтобы гарантировать
точность алгоритма в~3/2 или 4/3 при условии, что получение каждой перестановки
тре\-бует не более чем $O(n\log n)$ операций? Для получения точности  3/2 они предложили алгоритм,
который строит две перестановки. Вопрос о~том, сколько перестановок  необходимо,
чтобы  точность  алгоритма  была равна 4/3,  остается неизученным.

В настоящей работе  предлагается приближенный алгоритм решения задачи с~гарантированной оценкой
 точности 3/2, который
 создает две перестановки: одну --- методом Шраге, а~вторую ---  алгоритмом с~невынужденными простоями  IJR. Построение каждой перестановки требует
  $O(n\log n)$ действий. Алгоритм   IJR является жадным,
но не списочным, и~его можно использовать как базовую эвристику
  при  составлении расписаний для различных моделей и~конструирования метода ветвей и~границ.

В списочных расписаниях сначала определяется множество  готовых заданий, а~затем из готовых выбирается
задание  с~максимальным приоритетом, для которого приоритет --- это время доставки.
 В~предложенном алгоритме
  выбираются два задания: самое приоритетное задание и~самое приоритетное
 из готовых. Затем  принимается решение, какое из двух заданий выполнять.


Основная идея алгоритма IJR состоит в следующем: иногда лучше поставить на обслуживание приоритетное задание, даже если это приведет к~простою процессора,
 чем загружать
процессор менее приоритетным. Установлены дополнительные условия,  в~которых выгодно
организовать
 невынужденный  простой процессора. Такие условия
  поз\-во\-ляют сделать выбор между
двумя заданиями.

Статья организована следующим образом. В~п. 2  излагаются новый приближенный алгоритм
построения расписания
с невынужденными простоями  IJR и~комбинированный алгоритм ICA, который строит две перестановки и~выбирает из них лучшую.
  В~п.~3  изучаются свойства построенного расписания и~доказывается
гарантированная оценка точности алгоритма ICA, равная 3/2. Рассматривается пример, показывающий, что данная оценка асимптотически
достигается.
В  п.~4  приведены результаты вычислительного эксперимента. В~п.~5 формулируются основные
результаты, полученные в~статье.




 {\bf 2. Алгоритмы  построения расписаний  IJR и~ICA.}
Сначала опишем алгоритм построения расписания с~невынужденными простоями IJR.

Введем следующие обозначения:  $r_{\min}=\min\{r(i ) |\ i \in U\}$,   $q_{\min}=\min\{q(i )\ |\ i \in U\}$.
  Определим нижнюю границу целевой функции $LB$ по формуле
        $$LB=\max\left\{r_{\min}+ \sum_{i=1}^{n}t(i)+q_{\min}, \max \{r(i)+t(i)+q(i)\ |\ i \in U\} \right\}.$$
 Отсортируем задания по неубыванию времен
поступления:  $r(j_1) \leq r(j_2) \leq \ldots \leq r(j_n)$.
Готовые задания будем хранить в~очереди с~приоритетами $Q_1$, приоритетом является время доставки.



Пусть   $time$ --- время освобождения процессора после выполнения уже поставленных в~расписание заданий,
  в~начальный момент времени  положим $time:=r_{\min}$.


        Пусть $k-1$ задание уже  поставлено в~расписание,   $S_{k-1}$ --- подмножество заданий, включенных
в расписание.
Известно время освобождения процессора:  $time:=\max\{\tau(i )+ t(i) | i \in S_{k-1}\}$.
 Опишем $k$-й шаг.







 1. Добавляем в~очередь $Q_1$ готовые задания такие, что $r(i) \leq time$.

  2.           Если очередь $Q_1$ пуста, то
                  $time:=\min\{r(i) | i \notin S_{k-1} \}$ и~переходим к~п. 1.

 3.         Выбираем готовое задание $u \in Q_1$  с~максимальным временем доставки
$q(u)=\max\{q(i) |i \in Q_1 \}.$

   4.   Положим  $r_{up}:=time+t(u)$.

5. Ищем задание  $u^*$, конкурирующее с~заданием $u$.
Для этого
находим первое по порядку, еще не включенное в~очередь $Q_1$ задание $j_i$  такое, что  $time < r(j_i) <r_{up}.$
Если такого задания нет, переходим к~п.~9.

6. Если выполнено  $q(j_i) >  LB/2,$  то
    для  задания $j_i$  определяем возможный простой процессора
${\rm idle}(j_i) = r(j_i) - time.$
 Проверяем  условие $q (j_i) - q(u)  \geq  {\rm idle}(j_i)$.

7. Если  условия п.~6 выполнены, то  устанавливаем на процессор задание
 $u^*=j_i$, положим $\tau(j_i):= r(j_i);$
                 $time:=\tau(j_i) +t(j_i);$
 переходим к~п. 1.
Иначе добавляем  задание $j_i$ в~очередь.

8. Если  $r(j_{i+1}) < r_{up},$  то положим  $i:=i+1,$  перейдем к~п. 6.

9.               Если  не нашли   задание  $u^*$,
                 то устанавливаем на процессор задание  $u$, положим
$\tau(u):=time;$
                 $time:=\tau(u) +t(u).$

10. Если $k < n$, то $k:=k+1$, затем  переходим к~п.~1.

11. Конец алгоритма, расписание
$S_n$  построено.



 Находим значение целевой функции  $C_{\max}(S_n)=\max\{\tau(i)+t(i)+q(i)   \ | \  i \in U\}$.

Опишем комбинированный алгоритм, который строит два расписания и~выбирает из них лучшее.


\emph{Комбинированный алгоритм построения расписания ICA}:


1. Строим расписание $S_{JR}$  алгоритмом JR, обозначим длину расписания  $C_{\max}(S_{JR})$.

2. Строим расписание $S$ алгоритмом IJR, обозначим длину расписания  $C_{\max}(S)$.

3. Выбираем расписание  $S_A$ с~меньшим значением целевой функции:
  $C_{\max}(S_A)=\min\{C_{\max}(S), C_{\max}(S_{JR})\}$.

 {\bf 3. Свойства расписания, построенного алгоритмом ICA.}
Рассмотрим свойства построенного расписания.
Пусть с~помощью алгоритма IJR сгенерировано расписание   $S,$ для каждого задания $j_i$
 определено
   время начала выполнения задания   $\tau(j_i)$.      Значение целевой функции равно   $C_{\max}(S)$.
Рассмотрим ряд определений, которые были введены в~[12] для  расписаний, построенных по правилу Джексона
и  являющихся важными характеристиками  при изучении
расписания с~простоями.
%\begin{definition}\rm

{\bf Определение 1.} {\it Критической}   работой называется работа  $j_c$  такая, что
$C_{\max}(S)=\tau(j_c)\, + \,t(j_c)\, + \,q(j_c)$.
Если таких работ несколько, то выберем самую раннюю в~расписании~$S$.
%\end{definition}
%\begin{definition}\rm

{\bf Определение 2.} {\it  Критической}  последовательностью в~расписании   $S$ называется последовательность работ
   $ J(S)=( j_a, j_{a+1},\ldots,j_c)$ такая, что  $j_c$ --- критическая работа
 и~в~расписании нет простоя процессора, начиная с~момента
начала работы $j_a$  до окончания работы  $j_c$.
%\end{definition}

Работа $j_a$ либо является самой первой  в~расписании, либо в~расписании перед ее началом процессор простаивает.
%\begin{definition}\rm

{\bf Определение 3.}  Работа  $j_u$ в~критической последовательности называется {\it интерференционной},
 если $q(j_u) < q(j_c)$ и~$q(j_i) \geq q(j_c)$ для  $i > u$.
%\end{definition}

{\bf Утверждение $[12]$.}
{\it  Если для всех работ критической последовательности верно, что $r(j_i)  \geq r(j_a)$   и~$q(j_i) \geq q(j_c),$
  то расписание оптимально.}

Введем определение задержанной работы, которая может встретиться в~расписаниях с~простоями.
%\begin{definition}\rm

{\bf Определение 4.}  Работу  $j_v$  из критической последовательности   будем  называть {\it задержанной}, если $r(j_v) < r(j_a)$.
%\end{definition}

Интерференционная работа может быть задержанной.

Сформулируем и~докажем два  свойства расписания, аналогичные свойствам расписаний,
 построенных по правилу Джексона [12].
%\begin{lemma}

{\bf Лемма 1.} {\it Если в~критической последовательности
 есть интерференционная работа $j_u$, то
  $C_{\max}(S) -C_{\max}(S_{\mathrm{opt}}) \leq t(j_u)-{\mathrm{idle}}$,
 где ${\mathrm{idle}} > 0$ --- возможный простой в~расписании. }
%\label{lemma_p}
%\end{lemma}

Д о~к~а з а~т е л ь с~т в~о.
 Обозначим общее время выполнения работ критической последовательности через $T(J(S))=\sum_{i=a}^{c}t(j_i)$,
 тогда $$C_{\max}(S)=r(j_a) +T(J(S))+q(j_c).$$ Если в~критической последовательности есть
 интерференционная работа $j_u$, то эту последовательность можно представить  как $J(S)=(S_1,j_u,S_2),$
 где $S_1$ --- последовательность работ до работы $j_u$, а~$S_2$ --- последовательность работ после $j_u$.

Получим, что в~момент времени
$t_1=r(j_a) +T(S_1)$   ни одна из работ последовательности  $S_2$ не готова к~выполнению.  Введем следующее обозначение:  $r_{\min}(S_2)=\min\{r(j_i) | j_i \in S_2\}$.
 Тогда выполнено  $t_1  <  r_{\min}(S_2)$.

Для оптимального расписания верно
$$C_{\max}(S_{\mathrm{opt}}) \geq r_{\min}(S_2)+T(S_2) +q(j_c),$$  откуда
$$C_{\max}(S) - C_{\max}(S_{\mathrm{opt}}) \leq r(j_a) +T(J(S))+q(j_c) -  r_{\min}(S_2)-T(S_2) -q(j_c)=$$
$$ =r(j_a) + T(S_1)+t(j_u) - r_{\min}(S_2)=t(j_u) -{\mathrm{idle}},$$
  где ${\mathrm{idle}}= r_{\min}(S_2)-t_1$ ---
 минимальный простой процессора,
 если вместо
ин\-тер\-фе\-рен\-цион\-ной работы поставить в~расписание работу из последовательности $S_2$. \hfill$\square$
%	\qed

Эта лемма уточняет свойство расписания Джексона, доказанное в~[12], и~показывает, что, убрав   интерференционную работу,
  можно получить выигрыш не больше, чем  $t(j_u)$ --- ${\mathrm{idle}}$.
%\begin{lemma}

{\bf Лемма 2.} {\itЕсли в~критической последовательности
 нет задержанных работ, то
  $C_{\max}(S) -C_{\max}(S_{\mathrm{opt}}) \leq  q(j_c)$.}
%\label{lemma_p}
%\end{lemma}

Лемма сформулирована и~доказана   Поттсом [12], для рассматриваемого алгоритма
 необходимо лишь добавить уточнение об отсутствии задержанных работ.

Пусть с~помощью алгоритма  IJR построено    расписание   $S,$  значение целевой функции для которого равно   $C_{\max}(S),$
  критическая последовательность  в~расписании   $ J(S)=( j_a, j_{a+1}, \ldots,j_c) $.
А с~помошью алгоритма  JR построено расписание $S_{JR}$,
  в~котором   критическая последовательность   $ J(S_{JR})=( z_a, z_{a+1}, \ldots,z_c) $.
%\begin{lemma}

{\bf Лемма 3.} {\itПусть в~критической последовательности    $ J(S)=( S_1, j_u,S_2)$ есть интерференционная работа  $j_u$.
  Если в~оптимальном расписании работа  $j_u$  выполняется после последовательности $S_2,$  то
верно
$C_{\max}(S)/C_{\max}(S_{\mathrm{opt}}) \leq 3/2$.}
%\end{lemma}

Д о~к~а з а~т е л ь с~т в~о.
Если в~оптимальном расписании работа  $j_u$  выполняется после последовательности $S_2, $  то
верно
$C_{\max}(S_{\mathrm{opt}}) \geq r_{\min}(S_2)+T(S_2)+t(j_u)+q(j_u).$

Тогда
$$C_{\max}(S) - C_{\max}(S_{\mathrm{opt}}) \leq r(j_a) +T(J(S))+q(j_c) -  r_{\rm min}(S_2)-T(S_2) -t(j_u)-q(j_u)=$$
$$={\mathrm{idle}} +q(j_c) -q(j_u).$$

Выберем   работу  $v \in S_2$ такую, что $r(v)=r_{\min}(S_2)$.


Тогда верно, что  либо
 $ {\mathrm{idle}}={\mathrm{idle}}(v)=r_{\min }(S_2) -r(j_a)-T(S_1) > q(v)-q(j_u) \geq  q(j_c)-q(j_u), $ либо $ q(c) \leq   q(v) < LB/2.$ \hfill$\square$
%	\qed

%\begin{lemma}


{\bf Лемма 4.} {\itПусть
  в~критической последовательности      $ J(S_{JR})=( F_1,j_u,F_2)$  есть интерференционная работа  $j_u$.
 Тогда если в~оптимальном расписании работа  $j_u$  выполняется до последовательности  $F_2$,  то
верно
$C_{\max}(S_{JR})/C_{\max}(S_{\mathrm{opt}}) \leq 3/2$.}
%\end{lemma}


Д о~к~а з а~т е л ь с~т в~о.
Если $t(j_u) \leq C_{\max}(S_{\mathrm{opt}})/2$, то утверждение леммы верно. Пусть  $t(j_u)  > C_{\max}(S_{\mathrm{opt}})/2.$
Если в~оптимальном расписании  $j_u$ выполняется
  до всех работ   последовательности $F_2$, то
$$ C_{\max}(S_{\rm opt}) \geq r(z_a)  +t(j_u)+T(F_2)+q(z_c).$$
Тогда $C_{\max}(S_{JR})  -  C_{\max}(S_{\mathrm{opt}}) \leq T(F_1) < LB/2$. \hfill$\square$
%	\qed

{\bf Теорема.} {\it С помощью алгоритма строится расписание   $S_A$, для которого\linebreak %\\
  $C_{\max}(S_A)/C_{\max}$  $(S_{\mathrm{opt}}) \leq 3/2$.
Вычислительная сложность алгоритма $O(n\log n)$.}

Д о~к~а з а~т е л ь с~т в~о.
Пусть с~помощью алгоритма  IJR построено    расписание   $S$, значение целевой функции которого равно   $C_{\max}(S)$,
  критическая последовательность     $ J(S)=( j_a, j_{a+1}, \ldots,j_c) $;
 с~помощью алгоритма  JR --- расписание $S_{JR}$,
 критическая последовательность     $ J(S_{JR})=( z_a, z_{a+1}, \ldots,z_c) $.

Рассмотрим следующие варианты.

1.  В~одной из построенных критических  последовательностей нет ин\-тер\-фе\-рен\-цион\-ных и~задержанных работ.
 Здесь  соответствующий  алгоритм построил оптимальное расписание.


2. В~каждой критической последовательности нашлась ин\-тер\-фе\-рен\-цион\-ная работа    $j_u$.
 Требуется рассмотреть случай, в~котором это одна и~та же  большая работа такая, что
 $t(j_u)  > C_{\max}(S_{\mathrm{opt}})/2.$


3. В~критической последовательности $ J(S_{JR})=( z_a, z_{a+1}, \ldots,z_c) $
 есть интерференционная работа, а~в~$ J(S)=( j_a, j_{a+1}, \ldots,j_c) $ --- задержанные работы.

Разберем  варианты 2 и~3.
 В~варианте 2 длина расписания $S_{JR}$ равна $C_{\max}(S_{JR})=r(z_a) +T(J(S_{JR}))+q(z_c).$


 Если $ t(j_u) \leq C_{\max}(S_{\mathrm{opt}})/2$, то  по лемме 1 утверждение теоремы выполнено.
 Пусть далее   $ t(j_u)  > C_{\max}(S_{\mathrm{opt}})/2$. Если время доставки критической
 работы $z_c$  не превосходит  $ C_{\max}(S_{\mathrm{opt}})/2$, то по лемме 2 утверждение теоремы выполнено.
Пусть  $q(z_c)  > C_{\max}(S_{\mathrm{opt}})/2$.


В силу доказанных лемм 3 и~4  достаточно рассмотреть случай, в~котором
 в~оптимальном расписании  работа $j_u$ должна стоять
  после  всех работ   по\-сле\-до\-ва\-тель\-нос\-ти $F_2$ и~до работ  по\-сле\-до\-ва\-тель\-нос\-ти  $S_2.$
 Это может быть только, если $r_{\min }(S_2) > r(z_c)+t(z_c)$.

Рассмотрим расписание  $S$, построенное алгоритмом IJR, его длина равна  $C_{\max}(S)=r(j_a) +T(J(S))+q(j_c).$

   Покажем, что если  работа $j_u$   стоит  в~$S$
  до  всех работ   последовательности $F_2,$ то  оценка точности алгоритма IJR равна 3/2.
Пусть  работа $j_u$   стоит  в~$S$
  до  всех работ   последовательности $F_2.$



 Так как $ t(j_u) > C_{\max}(S_{\mathrm{opt}})/2$, а~ $q(j) > C_{\max}(S_{\mathrm{opt}})/2$  для
 $j  \in F_2$  и~$r(j) < C_{\max}(S_{\mathrm{opt}})/2,$  то
все работы  последовательности $F_2$ являются  конкурирующими
  для $j_u$ и~должны входить в~последовательность $S_2$ критической последовательности $J(S)$.
 В~расписании $S$  работа  $j_u$ может стоять
  до всех работ   последовательности $F_2$, только
  если
 по\-тен\-циаль\-ный
 простой ${\mathrm{idle}}(u^*)$ перед конкурирующей работой  $u^*$  велик и~верно неравенство $q(u^*) -q(j_u) <{\mathrm{idle}}(u^*)$.

Выберем   работу  $v \in S_2$ такую, что $r(v)=r_{\min}(S_2)
=r_{\min}(F_2)$.
Тогда верно, что   ${\mathrm{idle}}={\mathrm{idle}}(v)=r_{\min }(F_2) -r(j_a)-T(F_1) > q(v)-q(j_u)$.
Тогда  по лемме 1 $$C_{\max}(S)  -  C_{\max}(S_{\mathrm{opt}}) \leq t(j_u) - {\mathrm{idle}}. $$
Покажем, что в~этом случае гарантированная оценка точности алгоритма IJR равна 3/2. Предположим противное, что
$$C_{\max}(S_{\mathrm{opt}})/2 < C_{\max}(S)  -  C_{\max}(S_{\mathrm{opt}}) \leq t(j_u) - {\mathrm{idle}}, $$
 тогда
$$C_{\max}(S_{\mathrm{opt}})/2 < t(j_u) - {\mathrm{idle}}. $$
 Следовательно,
$q(v) -q(j_u)+ C_{\max}(S_{\mathrm{opt}})/2 < t(j_u)$,
откуда $$C_{\max}(S_{\mathrm{opt}}) < t(j_u)+ q(j_u) < LB.$$
Получили противоречие, следовательно, если алгоритм IJR поставил  работу $j_u$   до $F_2$,
 то  оценка точности алгоритма равна 3/2.

Если  алгоритм IJR поставил работу  $j_u$    после  последовательности $F_2$, то возможны два случая.

 {\it Первый случай}: в~расписании  $S$ нет простоев после  выполнения работы $z_c$
 и~до конца критической последовательности  работы $j_c$, тогда в~оптимальном
 расписании работа  $j_u$  выполняется между $j_a$ и~ $j_c$.

Если в~оптимальном расписании работа  $j_u$ выполняется между работами $j_a$ и~$j_c,$
тогда $$C_{\max}(S_{\mathrm{opt}}) \geq  r(j_a)+t(j_u)+ T(S_2)+q(j_c).$$

Таким образом,
 $$C_{\max}(S)-C_{\max}(S_{\mathrm{opt}}) \leq r(j_a) +T(S_1)+t(j_u) +T(S_2)+
q(j_c) - \, $$
$$  - \, r(j_a)-t(j_u)- T(S_2)-q(j_c)=
T(S_1)
 \leq LB/2.$$

В этом случае алгоритм   IJR построит расписание с~оценкой 3/2.

{\it Второй случай}:   $r(j_a) > \max\{\tau(z_c) +t(z_c), r_{\rm min}(F_2)+T(F_2)\}$.
 По свойствам алгоритма  IJR  процессор простаивает  до момента времени $r(j_a)$ и~$q(j_a) > LB/2.$

  Тогда
 в~оптимальном расписании работа  $j_u$  может выполняться между работами $j_a$ и~$j_c$ или до работы  $j_a.$


Осталось рассмотреть случай, когда в~оптимальном расписании  $j_u$
 выполняется после работы $z_c$ и~до работы  $j_a.$
Тогда
$C_{\max}(S_{\mathrm{opt}}) \geq r_{\min}(F_2)+T(F_2)+t(j_u)+t(j_a)+q(j_a).$

  Следовательно,
$$C_{\max}(S_{JR})-C_{\max}(S_{\mathrm{opt}}) \leq  r(z_a) +T(J(S_{JR}))+q(z_c)\, - $$
%
$$- \, r_{\min}(F_2)-T(F_2)-t(j_u)-t(j_a)-q(j_a) =$$
%
$$= r(z_a) +T(F_1)+q(z_c)-r_{\min}(F_2)-t(j_a)- q(j_a) < $$
%
$$ < q(z_c)- q(j_a) < LB/2.$$
Это верно, так как $q(z_c) < LB$ и~$q(j_a)> LB/2$. В~этом случае алгоритм Шраге по\-строит расписание с~оценкой, равной  3/2.











 В~варианте 3, если в~критической последовательности $ J(S)$  нет интер\-фе\-рен\-цион\-ной  работы, то   $q(j_i)  \geq q(j_c)$
  для всех работ из критической  последовательности  $j_i \in J(S)$.
Но в~критической последовательности есть работы, которые можно начать раньше первой работы $j_a$. Пусть $ r(J(S))=\min\{r(j_i) \ | \ j_i \in J(S)\}.$

  Тогда
$$ C_{\max}(S_{\rm opt}) \geq r(J(S))  +T(J(S))+q(j_c),$$
$$ C_{\max}(S)-C_{\max}(S_{\rm opt}) \leq  r(j_a) +T(J(S))+q(j_c) - r(J(S)) -T(J(S))-q(j_c)=$$  $$=r(j_a)- r(J(S))  < LB/2.$$
По свойствам алгоритма
         $ r(j_a)  < LB/2$.

 Гарантированная оценка точности доказана.


Рассмотрим трудоемкость алгоритма построения расписания.
Алгоритм строит\linebreak две перестановки: одну --- алгоритмом JR, вычислительная сложность которого $O(n\log n)$, вторую --- алгоритмом IJR. Покажем,
 что для  алгоритма IJR вычислительная сложность  $O(n\log n)$.
Сначала задания
сортируются  по неубыванию времен
поступления: $r(j_1) \leq r(j_2) \leq \ldots \leq r(j_n)$, этот шаг требует   $O(n\log n)$ действий. Основной
операцией является выбор задания из множества готовых заданий в~момент времени $time$.
 Готовые задания будем хранить, как очередь с~приоритетами $Q_1$, которую
 можно организовать в~виде двоичной кучи,  приоритетом будет время доставки $q(j)$.

 На шаге 1 алгоритма добавляем в~очередь новые готовые задания такие, что $r(j_i) \leq time$, добавление
 каждого требует  $O(\log n)$ действий.
 Задание  $u$ с~максимальным приоритетом выбирается
 за  $O(1)$ действий. Полагаем, что  $r_{up}=time+t(u)$.

На шагах 5--8   добавляем в~очередь новые готовые задания, для которых
 $r(j_i) <  r_{up}$. Если нашлось  задание, для которого выполнены условия п.~6,
 то ус\-та\-нав\-ли\-ваем его  на процессор. Иначе --- просматриваем всех кандидатов, помещая
 их в~очередь,   и~ставим  на процессор задание $u$.

Для  постановки в~расписание выбирается  задание  $u^*$ или  $u$,  что требует
   $O(1)$ действий, и~поставленное задание  удаляется
 из очереди  $Q_1$, что требует  $O(\log n)$ действий.

Каждое задание может быть добавлено в~очередь не более одного  раза:  по\-строе\-ние двоичной кучи требует
   $O(n\log n)$ действий.
 Общая вычислительная сложность
  $O(n\log n)$. \hfill$\square$
%	\qed

Приведем пример, в~котором оценка достигается.

%\begin{lemma}
{\bf Лемма 5.} {\itСуществует  пример, для которого  отношение %\\
  $C_{\max}(S_A)/C_{\max}(S_{\mathrm{opt}})$ стремится к~3/2. }
%\end{lemma}

Д о~к~а з а~т е л ь с~т в~о.
    Рассмотрим систему из следующих заданий $x,a,u,c$. Данные  для системы заданий приведены в~табл.~1, где $M$ --- константа.


\begin{table}[h!]
\begin{center}
{\small

{\it Таблица 1.} {\bf Данные для системы заданий}%

}

\vskip 3mm

{\footnotesize

\begin{tabular}{|c|c|c|c|}
            \hline
            $Job$& $r_i$ & $t_i$ & $q_i$\\ \hline
             $x$ & $\varepsilon$ &$\varepsilon$ & $M-2\varepsilon$\\  \hline
            $a$  & $M/2 -\varepsilon$ & $\varepsilon$     & $M/2$\\ \hline
           $ u$  & 0                  &$M/2 +\varepsilon$ &0\\ \hline

            $c$  & $M/2 +\varepsilon$ & $\varepsilon$     & $M/2 -2\varepsilon$ \\ \hline

\end{tabular}

}
\end{center}\vspace{-3mm}
\end{table}
%\vskip 2mm


Нижняя оценка целевой функции $LB=M.$ %\\
Алгоритм  IJR  построит расписание $S= (x,a,u,c)$. Перед началом выполнения задания $a$ процессор будет простаивать
 $M/2 -\varepsilon$ единиц времени.

Значение целевой функции
$C_{\max}(S)=M/2 -\varepsilon +\varepsilon+M/2 +\varepsilon +\varepsilon+ M/2 -2\varepsilon = 3/2 M. $\\
Алгоритм  JR построит расписание $S_{JR}= (u,x,a,c)$.
Значение целевой функции
$C_{\max}(S_{JR})=M/2 +\varepsilon +  M-2\varepsilon = 3/2 M -\varepsilon. $%\\

Оптимальное расписание $S_{\mathrm{opt}}=(x,u,a,c)$, значение целевой функции  для которого
 $C_{\max}(S_{\mathrm{opt}})=2\varepsilon +M/2+\varepsilon+M/2 -2\varepsilon=M +\varepsilon$. %
%
При  $\varepsilon$, стремящимся к~нулю, отношение
$C_{\max}(S_A)/ C_{\max}(S_{\mathrm{opt}})$ стремится к~3/2.
	\qed

    {\bf 4. Вычислительный эксперимент.}
Для выяснения практической эффективности  алгоритма был проведен вычислительный эксперимент. Его целями  были:

---	программная реализация предложенного алгоритма;

---	проверка быстродействия и~эффективности алгоритма и~экспериментальная оценка его точности на случайных тестовых примерах;

---	сравнение точности алгоритма IJR с~точностью алгоритма JR.
Сравнение точности комбинированного алгоритма IСA с~точностью алгоритма NS.

Исходные данные генерировались методом, описанным Дж. Карлье [17]. Такой же метод
 генерирования
тестовых примеров   использовали Е. Новицкий  и~К. Смутницкий     при сравнении предложенного
 ими алгоритма с~алгоритмами
 Холл, Шмойса и~Шраге.  Для каждого задания с~равной вероятностью выбираются целочисленные
значения $q(i)$  из диапазона
от 1 до $q_{\max}$, значения  $r(i)$  из диапазона от 1 до  $r_{\max}$ и~$t(i)$ из диапазона
от 1 до     $t_{\max.}$

Были установлены следующие значения: $t_{\max}=50,$ $r_{\max}=q_{\max}=nK$. Были рассмотрены
 примеры при  $K$  от 10 до 22, которые были отмечены Карлье как наиболее трудные для рассматриваемой задачи. Для
каждого значения  $n$ и~$K$  строилось расписание для 100 тестов.
Были рассмотрены три группы примеров.
 Времена выполнения заданий для каждой из групп  выбирались из  следующих интервалов:


1) $t(j) $  из $[ 1, t_{\max}]$;

2)   $t(j)$  из $[ 1, t_{\max}/2]$  для  $j \in 1: n-1$  и~$t(j_n)$ из $[n t_{\max}/8, 3n t_{\max}/8]$;

3)  $ t(j)$  из  $[ 1, t_{\max}/3]$  для $j \in 1: n-2$ и~$t(j_{n-1}), t(j_n)$  из $[n t_{\max}/12, 3 n t_{\max}/12]$.

Группы 2  и~3 содержат примеры с~одним и~двумя длительными заданиями.
Величина целевой функции $C_{\max}$  сравнивалась с~оптимальным значением целевой функции $C_{\mathrm{opt}}$,
которое было получено методом ветвей и~границ.   В  табл. 2--5 $n$ --- количество заданий в~тесте.
 В~табл. 2 оно  изменялось
 от 50 до 5000  и~для всех  тестов было выбрано  $K=20$.




 Результаты работы  приближенных алгоритмов  IJR, JR и~NS для задачи с~одним процессором
для  группы тестов  1  показаны в~табл.~2.

В столбцах $N_{\mathrm{IJR}}$, $N_{\mathrm{JR}}$ и $N_{\mathrm{NS}}$  табл. 2  приведено  количество тестов  в~процентах, для которых были получены
 оптимальные решения алгоритмами  IJR, JR и~NS соот\-ветст\-венно.
 В~следующих трех столбцах  содержится среднее значение отношения   $R=C_{\max}/C_{\mathrm{opt}}$
 для этих алгоритмов    по всем тестам.

\pagebreak


%\vskip 2mm
\begin{table}[h!]
\begin{center}
{\small

{\it Таблица 2.} {\bf Результаты работы  приближенных алгоритмов\\ для группы тестов 1}%

}

\vskip 3mm

{\footnotesize

\begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            $n$ & $N_{\mathrm{IJR}}$& $N_{\mathrm{JR}}$ & $N_{\mathrm{NS}}$ & $R_{\mathrm{IJR}}$  & $R_{\mathrm{JR}}$  &$R_{\mathrm{NS}}$   \\ \hline
            50  &   81    & 5      &  74    &     1.00030    &   1.0097      &  1.00250   \\
            100 &   97   & 6      & 94       &    1.00006   &  1.0091  &   1.00010            \\
             300 &   96    &  0       &  88   &    1.00005 &   1.0015          &    1.00009          \\
            500 & 80     & 0        &  56    &     1.00004  &   1.0009    &   1.00020   \\
            1000 & 96   & 0         &  93   &     1.00000  &   1.00009    &   1.00002   \\
            2000 & 92   &  1         &  88     &     1.00001  &   1.0002    &   1.00002   \\
            5000 & 96   &  2         &  91     &     1.00000  &   1.0001    &   1.00001   \\ \hline
\end{tabular}

}
\end{center}\vspace{-3mm}
\end{table}
%\vskip 2mm


Из   табл.~2 видно, что по проценту оптимальных решений алгоритм  IJR  лучше алгоритмов  NS и~JR.  Алгоритм JR очень редко получает
 оптимальное решение. Средняя относительная погрешность  решения невелика у~всех алгоритмов и~составляет самое
  большее 0.005\,\% для алгоритма    IJR, самое большее 0.97\,\% для алгоритма  JR и~0.2\,\% для алгоритма NS.

В табл. 3 приведены результаты экспериментов, в~которых проверялась зависимость работы алгоритмов от изменения
 константы $K$. Остальные столбцы этой таблицы  аналогичны столбцам
 табл. 2. Из табл. 3 видно, что изменение константы  $K$ от 10 до 22 не оказывает заметного влияния на работу алгоритмов.



%\vskip 2mm
\begin{table}[h!]
\begin{center}
{\small

{\it Таблица 3.} {\bf Зависимость работы алгоритмов от константы $K$}%

}

\vskip 3mm

{\footnotesize

\begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline
             $n$ & $K$ & $N_{\mathrm{IJR}}$& $N_{\mathrm{JR}}$ & $N_{\mathrm{NS}}$ & $R_{\mathrm{IJR}}$  & $R_{\mathrm{JR}}$ &$R_{\mathrm{NS}}$\\ \hline

            100  &  10 &   98   & 2      &    88    &  1.00001    &   1.003      &  1.0001   \\
            100  &  14  &   95     &  0        &    91     &   1.00002   &   1.004      &  1.0005   \\
            100 &   15  &   92    &   1      &  89     &   1.00007 &   1.002  & 1.0010       \\
            100 &  16   &    93    &  2      &   91      &    1.00001    &  1.005   &   1.0001   \\
            100 &  18    &    97   &  0 &    87       &     1.00001   &   1.003    &   1.0001   \\
             100 & 20     &  92   & 4  &     91          &  1.00006  & 1.009  & 1.0001              \\
             100 & 22     & 93   & 2  &     88        &1.00004  &  1.003  & 1.0002                 \\
      \hline
\end{tabular}

}
\end{center}\vspace{-3mm}
\end{table}
%\vskip 2mm



Из теоретического анализа алгоритмов можно предположить, что наиболее трудные примеры будут  иметь
 место, когда есть одно или два задания, значительно отличающиеся от остальных по длительности. Такие тесты генерировались в~группах~2 и~3.
В табл.~4 и~5  приведены результаты сравнения алгоритмов для тестов групп~2 и~3 соответственно.
 Для этих групп тестов  рассматривался комбинированный алгоритм ICA, в~котором из двух решений,
 полученных алгоритмами   JR и~IJR, выбиралось лучшее. В~двух последних столбцах  таблиц  $R_{\rm ICA}=C_{\rm max}(S_A)/C_{\rm opt}$~---
значение средней относительной погрешности для комбинированного алгоритма  и~$N_{\rm ICA}$~--- количество оптимальных решений в~процентах для комбинированного алгоритма.


%\vskip 2mm
\begin{table}[h!]
\begin{center}
{\small

{\it Таблица 4.} {\bf Результаты сравнения алгоритмов для тестов  группы 2}%

}

\vskip 3mm

{\footnotesize

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
            \hline
   $n$ & $ K $ & $N_{\mathrm{IJR}}$& $N_{\mathrm{JR}}$ & $N_{\mathrm{NS}}$ &  $R_{\mathrm{IJR}}$  & $R_{\mathrm{JR}}$  &$R_{\mathrm{NS}}$ &  $R_{\mathrm{ICA}}$  & $N_{\mathrm{ICA}}$\\

  \hline     100  &  10 &   51  & 23      &    25       &  1.02    &   1.05      &  1.04  & 1.005 & 58\\
            100  &  14  &   29     &  47        &    48     &   1.06   &   1.03      &  1.03   &1.004 &62\\
            100 &   15  &   25    &   48      &  49         &   1.05 &   1.04    & 1.04   & 1.007  &  59\\
            100 &  16   &    53    &  21      &   34      &    1.01    &  1.04   &   1.01 & 1.004 & 69\\
            100 &  18    &    46   &  46 &    49          &     1.05   &   1.04    &   1.03  &1.005 &  71\\
             100 & 20     &  24   & 15  &     16         &  1.05       & 1.06  & 1.03  & 1.007     &    33   \\
             100 & 22     & 44   & 29  &     33        &1.02          &  1.03  & 1.03   & 1.006    &   57       \\
      \hline
\end{tabular}

}
\end{center}\vspace{-3mm}
\end{table}
%\vskip 2mm



%\vskip 2mm
\begin{table}[h!]
\begin{center}
{\small

{\it Таблица 5.} {\bf Результаты сравнения алгоритмов для тестов  группы 3}%

}

\vskip 3mm

{\footnotesize

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
            \hline
   $n$ & $K$ & $N_{\mathrm{IJR}}$& $N_{\mathrm{JR}}$ & $N_{\mathrm{NS}}$ &  $R_{\mathrm{IJR}}$  & $R_{\mathrm{JR}}$  &$R_{\mathrm{NS}}$ &  $R_{\mathrm{ICA}}$  & $N_{\mathrm{ICA}}$\\

  \hline     100  &  10 &   48   & 35      &    42    &  1.04    &   1.05      &  1.04  & 1.006&  59\\
            100  &  14  &   55     &  29        &    29     &   1.02   &   1.04      &  1.04   &1.005 & 68\\
            100 &   15  &   25     &   43      &  44     &   1.06 &   1.03  & 1.02   & 1.006 & 57  \\
            100 &  16   &    36    &  39      &   41      &    1.05    &  1.04   &   1.04 & 1.005 &  66\\
            100 &  18    &    40   &  40 &    41      &     1.06   &   1.05    &   1.05  &1.004 & 72\\
             100 & 20     &  42   & 25  &     26          &  1.08  & 1.01  & 1.01  & 1.005  &   58       \\
             100 & 22     & 24   & 14  &     16        &1.06  &  1.07  & 1.07   & 1.008  &      36      \\
      \hline
\end{tabular}

}
\end{center}\vspace{-3mm}
\end{table}
%\vskip 2mm



Из   табл.~4 и~5  видно, что для тестов с~двумя или одной продолжительной работой
процент оптимальных решений у~алгоритмов IJR и~NS уменьшается, а~у~алгоритма JR  увеличивается.
Для тестов с~одной длительной работой (табл. 4)
процент оптимальных решений у~алгоритма IJR для трех наборов тестов примерно в~2 раза больше, чем у~алгоритмов  NS  и~JR.
Для двух наборов приблизительно в~2 раза меньше. Для одного набора  получено примерно одинаковое количество оптимальных решений.
Для тестов с~двумя продолжительными заданиями результаты аналогичные.
Относительная погрешность  решения  увеличивается  у~всех алгоритмов и~составляет в~среднем
от 1 до 6\,\%.


По результатам, приведенным в~табл. 4 и~5, трудно выделить лучший алгоритм из JR, IJR и~NS.
Алгоритм NS строит два решения: одно --- алгоритмом JR,
 а~затем, используя полученную информацию, пытается его улучшить. Для тестов  группы 1 это улучшение часто было значительным,
 а~для групп 2 и~3 результаты алгоритма существенно не меняются.
Значительно лучшими
показателями обладает комбинированный алгоритм ICA: в~нем сочетаются преимущества алгоритма JR,   не допускающего
невынужденных простоев, и~предложенного автором алгоритма IJR, который их разрешает.


Применение комбинированного алгоритма ICA
существенно улучшает относительную погрешность решения. Для этого алгоритма
 она составляет от 0.4 до 0.8\,\%.
 Худшие решения для алгоритма JR  имели относительную погрешность 23\,\%,
для алгоритма IJR~---  19\,\%,
 а~для комбинированного алгоритма ICA --- только  7\,\%. В~процессе тестирования не было получено теста,
 для которого алгоритмы JR и~IJR построили решение с~большой относительной погрешностью.
 Количество оптимальных решений  также возрастает
 для комбинированного алгоритма ICA.
 Комбинированный алгоритм ге\-не\-ри\-рует две перестановки, как и~алгоритм NS,
но его средняя относительная погрешность существенно  меньше, а~полученных оптимальных решений больше.










{\bf 5. Заключение.}
В работе рассмотрена задача составления расписания для одного процессора
с временами поступления и~временами доставки заданий. Целью яв\-ляет\-ся
 минимизация общего времени выполнения всех заданий. Предложен новый
  алгоритм с~гарантированной оценкой точности, равной
3/2, и~вычислительной сложностью $O(n\log n)$, в~котором приоритет задания учитывается в~первую очередь
 и~допускаются простои процессора при выполнении определенных условий. Приведен пример,
в котором достигается гарантированная оценка точности.
Вычислительный эксперимент подтвердил практическую эффективность алгоритма.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\input{02/lit-ra}

%\newpage
\input{02/ref-s}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{\footnotesize

%\thispagestyle{empty}
%
\vskip 3mm
%
\thispagestyle{empty} %очищаем стиль страницы
\thispagestyle{fancy} %включаем пользовательский стиль
\renewcommand{\headrulewidth}{0pt}%
\fancyhead[LO]{}%
\fancyhead[RE]{}%
\fancyfoot[LO]{\footnotesize{\rm{Вестник~СПбГУ.~Прикладная~математика.~Информатика...~\issueyear.~Т.~17.~Вып.~\issuenum}}
\hfill}%
\fancyfoot[RE]{\hfill\footnotesize{\rm{Вестник~СПбГУ.~Прикладная~математика.~Информатика...~\issueyear.~Т.~17.~Вып.~\issuenum}}}%
% для оформления нижнего колонтитула
\cfoot{} %


%}
